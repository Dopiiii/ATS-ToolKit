"""ICS vulnerability checker — matches device info against a built-in database of known ICS CVEs."""

import json
import re
from typing import Any

from src.core.base_module import AtsModule, ModuleSpec, ModuleCategory, Parameter, ParameterType, OutputField


# Built-in ICS vulnerability database (representative subset)
ICS_CVE_DATABASE = [
    {"cve": "CVE-2023-3595", "vendor": "rockwell", "product": "controllogix", "severity": "critical",
     "cvss": 9.8, "description": "Remote code execution in Rockwell ControlLogix communication modules",
     "affected_versions": ["<33.011", "<34.011"], "protocol": "EtherNet/IP"},
    {"cve": "CVE-2023-3596", "vendor": "rockwell", "product": "guardlogix", "severity": "critical",
     "cvss": 9.1, "description": "Denial of service in Rockwell 1756-EN4TR communication modules",
     "affected_versions": ["<33.011"], "protocol": "EtherNet/IP"},
    {"cve": "CVE-2022-45092", "vendor": "siemens", "product": "s7-1500", "severity": "critical",
     "cvss": 9.8, "description": "Arbitrary code execution in SINEMA Remote Connect Server",
     "affected_versions": ["<3.1"], "protocol": "S7comm"},
    {"cve": "CVE-2022-38465", "vendor": "siemens", "product": "s7-1200", "severity": "critical",
     "cvss": 9.3, "description": "Global private key extraction in S7-1200/S7-1500 PLCs",
     "affected_versions": ["<4.5"], "protocol": "S7comm"},
    {"cve": "CVE-2023-28489", "vendor": "siemens", "product": "cp-8031", "severity": "critical",
     "cvss": 9.8, "description": "Unauthenticated remote code execution in SICAM CP devices",
     "affected_versions": ["<CPCI85 V05"], "protocol": "Multiple"},
    {"cve": "CVE-2023-1619", "vendor": "wago", "product": "pfc200", "severity": "high",
     "cvss": 7.5, "description": "Denial of service via crafted CODESYS packets",
     "affected_versions": ["<03.10.10"], "protocol": "CODESYS"},
    {"cve": "CVE-2022-2003", "vendor": "ge", "product": "cimplicity", "severity": "high",
     "cvss": 7.8, "description": "Code execution via specially crafted CIM project files",
     "affected_versions": ["<2023"], "protocol": "SRTP"},
    {"cve": "CVE-2023-2611", "vendor": "advantech", "product": "r-seenet", "severity": "critical",
     "cvss": 9.8, "description": "Hard-coded credentials in Advantech R-SeeNet monitoring",
     "affected_versions": ["<3.3.0"], "protocol": "HTTP"},
    {"cve": "CVE-2022-2463", "vendor": "schneider", "product": "modicon_m340", "severity": "high",
     "cvss": 8.1, "description": "Authentication bypass on Modicon M340 processors via Modbus",
     "affected_versions": ["<3.50"], "protocol": "Modbus"},
    {"cve": "CVE-2023-29444", "vendor": "schneider", "product": "igss", "severity": "high",
     "cvss": 7.8, "description": "Code execution in IGSS SCADA through malicious project files",
     "affected_versions": ["<16.0.0.23040"], "protocol": "Multiple"},
    {"cve": "CVE-2022-4048", "vendor": "codesys", "product": "runtime", "severity": "high",
     "cvss": 7.7, "description": "Weak encryption in CODESYS communication allowing session hijack",
     "affected_versions": ["<3.5.18.40"], "protocol": "CODESYS"},
    {"cve": "CVE-2023-0053", "vendor": "hitachi", "product": "energy_gms600", "severity": "high",
     "cvss": 8.2, "description": "Hard-coded credentials in Hitachi Energy GMS600/PWC600",
     "affected_versions": ["<1.3.0"], "protocol": "IEC 61850"},
]


def version_matches(device_version: str, affected_spec: str) -> bool:
    """Simple version matching: check if device version is below the patched version."""
    match = re.match(r"[<>]=?\s*v?(\d[\d.]*)", affected_spec, re.IGNORECASE)
    if not match:
        return True  # If we can't parse, assume potentially affected
    patched = match.group(1)
    try:
        dev_parts = [int(x) for x in re.findall(r"\d+", device_version)]
        patch_parts = [int(x) for x in re.findall(r"\d+", patched)]
        for d, p in zip(dev_parts, patch_parts):
            if d < p:
                return True
            elif d > p:
                return False
        return len(dev_parts) <= len(patch_parts)
    except (ValueError, IndexError):
        return True


class IcsVulnerabilityCheckModule(AtsModule):
    """Check ICS device information against a built-in database of known vulnerabilities."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="ics_vulnerability_check",
            category=ModuleCategory.ADVANCED,
            description="Check ICS devices against known vulnerability database",
            version="1.0.0",
            parameters=[
                Parameter(name="device_info", type=ParameterType.STRING,
                          description='JSON string with device details: {"vendor":"...","model":"...","version":"..."}'),
                Parameter(name="check_scope", type=ParameterType.CHOICE,
                          description="Check only critical CVEs or all severities",
                          default="all", choices=["critical", "all"]),
                Parameter(name="include_details", type=ParameterType.BOOLEAN,
                          description="Include full CVE details in output", default=True),
            ],
            outputs=[
                OutputField(name="vulnerabilities", type="list", description="Matching CVE entries"),
                OutputField(name="risk_summary", type="dict", description="Risk summary with counts"),
                OutputField(name="recommendations", type="list", description="Remediation recommendations"),
            ],
            tags=["advanced", "ics", "vulnerability", "cve"],
            dangerous=False,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        if not config.get("device_info", ""):
            return False, "Device info JSON is required"
        try:
            info = json.loads(config["device_info"])
            if not isinstance(info, dict):
                return False, "Device info must be a JSON object"
            if not info.get("vendor"):
                return False, "Device info must include 'vendor' field"
        except json.JSONDecodeError as exc:
            return False, f"Invalid JSON: {exc}"
        return True, ""

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        device = json.loads(config["device_info"])
        scope = config.get("check_scope", "all")
        include_details = config.get("include_details", True)

        vendor = device.get("vendor", "").lower().strip()
        model = device.get("model", "").lower().strip()
        version = device.get("version", "").strip()

        matches: list[dict[str, Any]] = []

        for cve_entry in ICS_CVE_DATABASE:
            if scope == "critical" and cve_entry["severity"] != "critical":
                continue

            vendor_match = vendor in cve_entry["vendor"] or cve_entry["vendor"] in vendor
            product_match = (not model) or model in cve_entry["product"] or cve_entry["product"] in model

            if vendor_match and product_match:
                version_vuln = True
                if version and cve_entry["affected_versions"]:
                    version_vuln = any(version_matches(version, av) for av in cve_entry["affected_versions"])

                if version_vuln:
                    entry: dict[str, Any] = {"cve": cve_entry["cve"], "severity": cve_entry["severity"],
                                              "cvss": cve_entry["cvss"]}
                    if include_details:
                        entry.update({
                            "description": cve_entry["description"],
                            "affected_versions": cve_entry["affected_versions"],
                            "protocol": cve_entry["protocol"],
                        })
                    matches.append(entry)

        matches.sort(key=lambda x: x["cvss"], reverse=True)

        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for m in matches:
            sev = m["severity"]
            severity_counts[sev] = severity_counts.get(sev, 0) + 1

        recommendations = []
        if severity_counts["critical"] > 0:
            recommendations.append("URGENT: Critical vulnerabilities found — apply vendor patches immediately")
        if severity_counts["high"] > 0:
            recommendations.append("HIGH: Segment affected devices behind firewalls with strict ACLs")
        if matches:
            recommendations.append("Review vendor security advisories for latest firmware updates")
            recommendations.append("Implement network monitoring for anomalous ICS traffic patterns")
            recommendations.append("Disable unnecessary protocols and services on affected devices")

        return {
            "device_queried": device,
            "vulnerabilities": matches,
            "risk_summary": {
                "total_matches": len(matches),
                "severity_breakdown": severity_counts,
                "highest_cvss": matches[0]["cvss"] if matches else 0.0,
                "risk_level": "critical" if severity_counts["critical"] else
                              "high" if severity_counts["high"] else
                              "medium" if matches else "low",
            },
            "recommendations": recommendations,
        }
