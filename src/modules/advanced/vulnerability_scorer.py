"""CVSS 3.1 vulnerability scoring module.

Calculates CVSS 3.1 base scores from vulnerability metric vectors,
providing severity labels, vector strings, and detailed breakdowns.
"""

import asyncio
import json
import math
import re
from typing import Any

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

# CVSS 3.1 metric value mappings
AV_VALUES = {"N": 0.85, "A": 0.62, "L": 0.55, "P": 0.20}
AC_VALUES = {"L": 0.77, "H": 0.44}
PR_VALUES_UNCHANGED = {"N": 0.85, "L": 0.62, "H": 0.27}
PR_VALUES_CHANGED = {"N": 0.85, "L": 0.68, "H": 0.50}
UI_VALUES = {"N": 0.85, "R": 0.62}
CIA_VALUES = {"H": 0.56, "L": 0.22, "N": 0.0}

AV_LABELS = {"N": "Network", "A": "Adjacent", "L": "Local", "P": "Physical"}
AC_LABELS = {"L": "Low", "H": "High"}
PR_LABELS = {"N": "None", "L": "Low", "H": "High"}
UI_LABELS = {"N": "None", "R": "Required"}
S_LABELS = {"U": "Unchanged", "C": "Changed"}
CIA_LABELS = {"N": "None", "L": "Low", "H": "High"}


class VulnerabilityScorerModule(AtsModule):
    """Calculate CVSS 3.1 base scores for vulnerabilities."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="vulnerability_scorer",
            category=ModuleCategory.ADVANCED,
            description="Calculate CVSS 3.1 base scores with severity labels, vector strings, and detailed breakdowns",
            version="1.0.0",
            parameters=[
                Parameter(name="vuln_data", type=ParameterType.STRING,
                          description="JSON object with: attack_vector (N/A/L/P), attack_complexity (L/H), "
                                      "privileges_required (N/L/H), user_interaction (N/R), scope (U/C), "
                                      "confidentiality (N/L/H), integrity (N/L/H), availability (N/L/H)"),
                Parameter(name="scoring_version", type=ParameterType.CHOICE,
                          description="Scoring methodology",
                          choices=["cvss31", "simple"], default="cvss31"),
            ],
            outputs=[
                OutputField(name="base_score", type="float", description="CVSS base score (0.0 - 10.0)"),
                OutputField(name="severity_label", type="string", description="Severity: None/Low/Medium/High/Critical"),
                OutputField(name="vector_string", type="string", description="CVSS vector string"),
                OutputField(name="breakdown", type="dict", description="Detailed score breakdown"),
            ],
            tags=["advanced", "vulnerability", "cvss", "scoring", "assessment"],
            author="ATS-Toolkit",
            dangerous=False,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        raw = config.get("vuln_data", "").strip()
        if not raw:
            return False, "Vulnerability data is required"
        try:
            data = json.loads(raw)
            if not isinstance(data, dict):
                return False, "Vulnerability data must be a JSON object"
        except json.JSONDecodeError as exc:
            return False, f"Invalid JSON in vuln_data: {exc}"

        required = {
            "attack_vector": list(AV_VALUES.keys()),
            "attack_complexity": list(AC_VALUES.keys()),
            "privileges_required": list(PR_VALUES_UNCHANGED.keys()),
            "user_interaction": list(UI_VALUES.keys()),
            "scope": ["U", "C"],
            "confidentiality": list(CIA_VALUES.keys()),
            "integrity": list(CIA_VALUES.keys()),
            "availability": list(CIA_VALUES.keys()),
        }
        for field, valid in required.items():
            val = data.get(field, "").upper()
            if not val:
                return False, f"Missing required field '{field}'"
            if val not in valid:
                return False, f"Invalid value '{val}' for '{field}'. Must be one of: {valid}"
        return True, ""

    def _score_cvss31(self, data: dict) -> dict[str, Any]:
        """Calculate CVSS 3.1 base score using the official formula."""
        av = data["attack_vector"].upper()
        ac = data["attack_complexity"].upper()
        pr = data["privileges_required"].upper()
        ui = data["user_interaction"].upper()
        s = data["scope"].upper()
        c = data["confidentiality"].upper()
        i = data["integrity"].upper()
        a = data["availability"].upper()

        # Metric values
        av_val = AV_VALUES[av]
        ac_val = AC_VALUES[ac]
        pr_val = PR_VALUES_CHANGED[pr] if s == "C" else PR_VALUES_UNCHANGED[pr]
        ui_val = UI_VALUES[ui]
        c_val = CIA_VALUES[c]
        i_val = CIA_VALUES[i]
        a_val = CIA_VALUES[a]

        # Impact Sub Score (ISS)
        iss = 1.0 - ((1.0 - c_val) * (1.0 - i_val) * (1.0 - a_val))

        # Impact
        if s == "U":
            impact = 6.42 * iss
        else:
            impact = 7.52 * (iss - 0.029) - 3.25 * ((iss - 0.02) ** 15)

        # Exploitability
        exploitability = 8.22 * av_val * ac_val * pr_val * ui_val

        # Base score
        if iss <= 0:
            base_score = 0.0
        elif s == "U":
            base_score = min(impact + exploitability, 10.0)
            base_score = math.ceil(base_score * 10) / 10
        else:
            base_score = min(1.08 * (impact + exploitability), 10.0)
            base_score = math.ceil(base_score * 10) / 10

        # Vector string
        vector_string = f"CVSS:3.1/AV:{av}/AC:{ac}/PR:{pr}/UI:{ui}/S:{s}/C:{c}/I:{i}/A:{a}"

        return {
            "base_score": base_score,
            "impact_sub_score": round(iss, 4),
            "impact": round(impact, 4),
            "exploitability": round(exploitability, 4),
            "vector_string": vector_string,
            "metrics": {
                "attack_vector": {"value": av, "label": AV_LABELS[av], "score": av_val},
                "attack_complexity": {"value": ac, "label": AC_LABELS[ac], "score": ac_val},
                "privileges_required": {"value": pr, "label": PR_LABELS[pr], "score": pr_val},
                "user_interaction": {"value": ui, "label": UI_LABELS[ui], "score": ui_val},
                "scope": {"value": s, "label": S_LABELS[s]},
                "confidentiality": {"value": c, "label": CIA_LABELS[c], "score": c_val},
                "integrity": {"value": i, "label": CIA_LABELS[i], "score": i_val},
                "availability": {"value": a, "label": CIA_LABELS[a], "score": a_val},
            },
        }

    def _score_simple(self, data: dict) -> dict[str, Any]:
        """Simple weighted scoring as an alternative to full CVSS."""
        weights = {"attack_vector": 2, "attack_complexity": 1.5, "privileges_required": 1.5,
                   "user_interaction": 1, "confidentiality": 2, "integrity": 2, "availability": 2}
        simple_map = {
            "attack_vector": {"N": 10, "A": 7, "L": 5, "P": 2},
            "attack_complexity": {"L": 10, "H": 5},
            "privileges_required": {"N": 10, "L": 6, "H": 3},
            "user_interaction": {"N": 10, "R": 5},
            "confidentiality": {"H": 10, "L": 5, "N": 0},
            "integrity": {"H": 10, "L": 5, "N": 0},
            "availability": {"H": 10, "L": 5, "N": 0},
        }
        total_weight = sum(weights.values())
        weighted_sum = 0.0
        metric_scores = {}
        for metric, w in weights.items():
            val = data.get(metric, "N").upper()
            raw_score = simple_map.get(metric, {}).get(val, 0)
            weighted_sum += raw_score * w
            metric_scores[metric] = {"value": val, "raw_score": raw_score, "weight": w}

        base_score = round(weighted_sum / total_weight, 1)
        s = data.get("scope", "U").upper()
        vector_string = (f"SIMPLE/AV:{data['attack_vector'].upper()}/AC:{data['attack_complexity'].upper()}"
                         f"/PR:{data['privileges_required'].upper()}/UI:{data['user_interaction'].upper()}"
                         f"/S:{s}/C:{data['confidentiality'].upper()}/I:{data['integrity'].upper()}"
                         f"/A:{data['availability'].upper()}")

        return {
            "base_score": base_score,
            "impact_sub_score": None,
            "impact": None,
            "exploitability": None,
            "vector_string": vector_string,
            "metrics": metric_scores,
        }

    @staticmethod
    def _severity_label(score: float) -> str:
        """Map numeric score to severity label per CVSS 3.1 spec."""
        if score == 0.0:
            return "None"
        elif score <= 3.9:
            return "Low"
        elif score <= 6.9:
            return "Medium"
        elif score <= 8.9:
            return "High"
        else:
            return "Critical"

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        data = json.loads(config["vuln_data"])
        version = config.get("scoring_version", "cvss31")

        if version == "cvss31":
            result = self._score_cvss31(data)
        else:
            result = self._score_simple(data)

        base_score = result["base_score"]
        severity = self._severity_label(base_score)

        return {
            "base_score": base_score,
            "severity_label": severity,
            "vector_string": result["vector_string"],
            "breakdown": {
                "scoring_version": version,
                "impact_sub_score": result["impact_sub_score"],
                "impact": result["impact"],
                "exploitability": result["exploitability"],
                "metrics": result["metrics"],
            },
        }
