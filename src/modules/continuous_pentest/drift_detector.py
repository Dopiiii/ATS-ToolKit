"""Configuration drift detector module.

Detect configuration drift from security baselines by comparing
current state against a known-good baseline and scoring severity.
"""

import asyncio
import json
from typing import Any, Dict, List, Tuple

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

# Keys considered security-relevant for severity scoring
SECURITY_RELEVANT_KEYS = {
    "open_ports", "ports", "firewall_rules", "security_headers",
    "ssl_version", "tls_version", "cipher_suites", "allowed_ciphers",
    "authentication", "auth_methods", "password_policy",
    "services", "running_services", "listeners",
    "permissions", "access_control", "acl",
    "encryption", "certificates", "ssh_config",
}

# Severity weights by sensitivity level
SENSITIVITY_WEIGHTS = {
    "low": {"added": 1, "removed": 2, "modified": 2, "security_bonus": 3},
    "medium": {"added": 2, "removed": 4, "modified": 3, "security_bonus": 5},
    "high": {"added": 3, "removed": 6, "modified": 5, "security_bonus": 8},
}


def _flatten_dict(data: Dict[str, Any], prefix: str = "") -> Dict[str, Any]:
    """Flatten a nested dictionary into dot-separated keys."""
    flat: Dict[str, Any] = {}
    for key, value in data.items():
        full_key = f"{prefix}.{key}" if prefix else key
        if isinstance(value, dict):
            flat.update(_flatten_dict(value, full_key))
        else:
            flat[full_key] = value
    return flat


def _is_security_relevant(key: str) -> bool:
    """Check if a key relates to security configuration."""
    key_lower = key.lower()
    return any(sec_key in key_lower for sec_key in SECURITY_RELEVANT_KEYS)


class DriftDetectorModule(AtsModule):
    """Detect configuration drift from security baselines."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="drift_detector",
            category=ModuleCategory.CONTINUOUS_PENTEST,
            description="Detect configuration drift from security baselines by comparing current state against known-good configurations",
            version="1.0.0",
            parameters=[
                Parameter(
                    name="baseline",
                    type=ParameterType.STRING,
                    description="JSON string of the known-good baseline configuration",
                    required=True,
                ),
                Parameter(
                    name="current_state",
                    type=ParameterType.STRING,
                    description="JSON string of the current configuration state",
                    required=True,
                ),
                Parameter(
                    name="sensitivity",
                    type=ParameterType.CHOICE,
                    description="Detection sensitivity level",
                    required=False,
                    default="medium",
                    choices=["low", "medium", "high"],
                ),
            ],
            outputs=[
                OutputField(name="drifts", type="list", description="List of detected configuration drifts"),
                OutputField(name="severity_scores", type="dict", description="Severity scores by drift category"),
                OutputField(name="recommendations", type="list", description="Remediation recommendations"),
            ],
            tags=["continuous", "drift", "baseline", "compliance", "configuration"],
            author="ATS-Toolkit",
            requires_api_key=False,
            api_key_service=None,
            dangerous=False,
        )

    def validate_inputs(self, config: Dict[str, Any]) -> Tuple[bool, str]:
        for field in ("baseline", "current_state"):
            raw = config.get(field, "").strip()
            if not raw:
                return False, f"{field} is required"
            try:
                parsed = json.loads(raw)
                if not isinstance(parsed, dict):
                    return False, f"{field} must be a JSON object"
            except json.JSONDecodeError as e:
                return False, f"{field} is not valid JSON: {e}"
        return True, ""

    async def execute(self, config: Dict[str, Any]) -> Dict[str, Any]:
        baseline_raw = json.loads(config["baseline"].strip())
        current_raw = json.loads(config["current_state"].strip())
        sensitivity = config.get("sensitivity", "medium")

        self.logger.info("drift_detection_start", sensitivity=sensitivity)

        weights = SENSITIVITY_WEIGHTS[sensitivity]

        baseline_flat = _flatten_dict(baseline_raw)
        current_flat = _flatten_dict(current_raw)

        baseline_keys = set(baseline_flat.keys())
        current_keys = set(current_flat.keys())

        added_keys = current_keys - baseline_keys
        removed_keys = baseline_keys - current_keys
        common_keys = baseline_keys & current_keys

        drifts: List[Dict[str, Any]] = []
        total_score = 0
        category_scores: Dict[str, int] = {"added": 0, "removed": 0, "modified": 0}

        # Detect added entries
        for key in sorted(added_keys):
            is_sec = _is_security_relevant(key)
            score = weights["added"] + (weights["security_bonus"] if is_sec else 0)
            category_scores["added"] += score
            total_score += score
            drifts.append({
                "type": "added",
                "key": key,
                "current_value": str(current_flat[key])[:200],
                "security_relevant": is_sec,
                "score": score,
            })

        # Detect removed entries
        for key in sorted(removed_keys):
            is_sec = _is_security_relevant(key)
            score = weights["removed"] + (weights["security_bonus"] if is_sec else 0)
            category_scores["removed"] += score
            total_score += score
            drifts.append({
                "type": "removed",
                "key": key,
                "baseline_value": str(baseline_flat[key])[:200],
                "security_relevant": is_sec,
                "score": score,
            })

        # Detect modified entries
        for key in sorted(common_keys):
            if baseline_flat[key] != current_flat[key]:
                is_sec = _is_security_relevant(key)
                score = weights["modified"] + (weights["security_bonus"] if is_sec else 0)
                category_scores["modified"] += score
                total_score += score
                drifts.append({
                    "type": "modified",
                    "key": key,
                    "baseline_value": str(baseline_flat[key])[:200],
                    "current_value": str(current_flat[key])[:200],
                    "security_relevant": is_sec,
                    "score": score,
                })

        severity_scores = {
            "total_score": total_score,
            "by_category": category_scores,
            "drift_count": len(drifts),
            "security_relevant_count": sum(1 for d in drifts if d["security_relevant"]),
        }

        # Generate recommendations
        recommendations: List[str] = []
        sec_removed = [d for d in drifts if d["type"] == "removed" and d["security_relevant"]]
        sec_modified = [d for d in drifts if d["type"] == "modified" and d["security_relevant"]]
        sec_added = [d for d in drifts if d["type"] == "added" and d["security_relevant"]]

        if sec_removed:
            keys_str = ", ".join(d["key"] for d in sec_removed[:5])
            recommendations.append(
                f"CRITICAL: {len(sec_removed)} security-relevant config(s) removed: {keys_str}. Restore immediately."
            )
        if sec_modified:
            keys_str = ", ".join(d["key"] for d in sec_modified[:5])
            recommendations.append(
                f"HIGH: {len(sec_modified)} security-relevant config(s) modified: {keys_str}. Review changes."
            )
        if sec_added:
            keys_str = ", ".join(d["key"] for d in sec_added[:5])
            recommendations.append(
                f"MEDIUM: {len(sec_added)} new security-relevant config(s) added: {keys_str}. Verify intentional."
            )
        if not drifts:
            recommendations.append("No configuration drift detected. Baseline is current.")

        self.logger.info("drift_detection_complete", drifts=len(drifts), total_score=total_score)

        return {
            "drifts": drifts,
            "severity_scores": severity_scores,
            "recommendations": recommendations,
        }
