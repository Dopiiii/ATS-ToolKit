"""Scheduled security scanner module.

Configure and manage scheduled security scans with target validation,
scan plan generation, and cron-like scheduling.
"""

import asyncio
import re
from typing import Any, Dict, List, Tuple
from urllib.parse import urlparse

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

# Scan type definitions with estimated durations per target (seconds)
SCAN_TYPES = {
    "ports": {
        "description": "TCP/UDP port scan of common and service ports",
        "estimated_duration_per_target": 120,
        "checks": ["top_1000_tcp", "top_100_udp", "service_detection"],
    },
    "headers": {
        "description": "HTTP security header analysis",
        "estimated_duration_per_target": 15,
        "checks": ["csp", "hsts", "x_frame_options", "x_content_type", "referrer_policy"],
    },
    "ssl": {
        "description": "SSL/TLS configuration and certificate analysis",
        "estimated_duration_per_target": 30,
        "checks": ["protocol_versions", "cipher_suites", "certificate_validity", "key_strength"],
    },
    "all": {
        "description": "Comprehensive scan including ports, headers, and SSL",
        "estimated_duration_per_target": 180,
        "checks": ["ports", "headers", "ssl", "dns_config", "common_vulns"],
    },
}

SCHEDULE_CONFIGS = {
    "hourly": {"cron": "0 * * * *", "interval_sec": 3600},
    "daily": {"cron": "0 2 * * *", "interval_sec": 86400},
    "weekly": {"cron": "0 2 * * 0", "interval_sec": 604800},
}

# Simple patterns for target validation
IP_PATTERN = re.compile(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
CIDR_PATTERN = re.compile(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/\d{1,2}$")
DOMAIN_PATTERN = re.compile(r"^[a-zA-Z0-9]([a-zA-Z0-9\-]*[a-zA-Z0-9])?(\.[a-zA-Z]{2,})+$")


class ScheduledScannerModule(AtsModule):
    """Configure and manage scheduled security scans."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="scheduled_scanner",
            category=ModuleCategory.CONTINUOUS_PENTEST,
            description="Configure and manage scheduled security scans with target validation and scan plan generation",
            version="1.0.0",
            parameters=[
                Parameter(
                    name="targets",
                    type=ParameterType.STRING,
                    description="Comma-separated list of targets (IPs, CIDRs, domains, or URLs)",
                    required=True,
                ),
                Parameter(
                    name="scan_types",
                    type=ParameterType.CHOICE,
                    description="Type of security scan to perform",
                    required=True,
                    choices=["ports", "headers", "ssl", "all"],
                ),
                Parameter(
                    name="schedule",
                    type=ParameterType.CHOICE,
                    description="How frequently to run the scan",
                    required=False,
                    default="daily",
                    choices=["hourly", "daily", "weekly"],
                ),
            ],
            outputs=[
                OutputField(name="scan_plan", type="dict", description="Complete scan plan with checks and configuration"),
                OutputField(name="targets_validated", type="list", description="Validated and categorized targets"),
                OutputField(name="schedule_config", type="dict", description="Cron schedule configuration"),
                OutputField(name="estimated_duration", type="string", description="Estimated total scan duration"),
            ],
            tags=["continuous", "scanning", "scheduled", "pentest", "automation"],
            author="ATS-Toolkit",
            requires_api_key=False,
            api_key_service=None,
            dangerous=False,
        )

    def validate_inputs(self, config: Dict[str, Any]) -> Tuple[bool, str]:
        targets = config.get("targets", "").strip()
        if not targets:
            return False, "targets is required"
        scan_types = config.get("scan_types", "")
        if scan_types not in SCAN_TYPES:
            return False, f"Invalid scan_types: {scan_types}"
        return True, ""

    def _validate_target(self, raw: str) -> Dict[str, Any]:
        """Validate and categorize a single target string."""
        target = raw.strip()
        if not target:
            return {"target": raw, "valid": False, "type": "empty", "reason": "Empty target"}

        # Check for URL
        if target.startswith(("http://", "https://")):
            parsed = urlparse(target)
            if parsed.hostname:
                return {"target": target, "valid": True, "type": "url", "hostname": parsed.hostname}
            return {"target": target, "valid": False, "type": "url", "reason": "Invalid URL"}

        # Check for CIDR
        if CIDR_PATTERN.match(target):
            return {"target": target, "valid": True, "type": "cidr"}

        # Check for IP
        if IP_PATTERN.match(target):
            octets = target.split(".")
            if all(0 <= int(o) <= 255 for o in octets):
                return {"target": target, "valid": True, "type": "ip"}
            return {"target": target, "valid": False, "type": "ip", "reason": "Invalid IP octets"}

        # Check for domain
        if DOMAIN_PATTERN.match(target):
            return {"target": target, "valid": True, "type": "domain"}

        return {"target": target, "valid": False, "type": "unknown", "reason": "Unrecognized target format"}

    async def execute(self, config: Dict[str, Any]) -> Dict[str, Any]:
        raw_targets = config["targets"].strip()
        scan_type = config["scan_types"]
        schedule = config.get("schedule", "daily")

        self.logger.info("building_scan_plan", scan_type=scan_type, schedule=schedule)

        # Validate targets
        target_list = [t.strip() for t in raw_targets.split(",") if t.strip()]
        targets_validated = [self._validate_target(t) for t in target_list]
        valid_count = sum(1 for t in targets_validated if t["valid"])

        # Build scan plan
        scan_def = SCAN_TYPES[scan_type]
        total_duration_sec = valid_count * scan_def["estimated_duration_per_target"]

        scan_plan = {
            "scan_type": scan_type,
            "description": scan_def["description"],
            "checks": scan_def["checks"],
            "total_targets": len(target_list),
            "valid_targets": valid_count,
            "alert_thresholds": {
                "new_open_port": "high",
                "ssl_expiry_days": 30,
                "missing_security_header": "medium",
                "critical_vuln_found": "critical",
            },
        }

        schedule_config = {
            "frequency": schedule,
            "cron_expression": SCHEDULE_CONFIGS[schedule]["cron"],
            "interval_seconds": SCHEDULE_CONFIGS[schedule]["interval_sec"],
            "next_run_note": f"Runs {schedule} per the cron expression",
        }

        # Human-readable duration
        if total_duration_sec >= 3600:
            duration_str = f"{total_duration_sec / 3600:.1f} hours"
        elif total_duration_sec >= 60:
            duration_str = f"{total_duration_sec / 60:.0f} minutes"
        else:
            duration_str = f"{total_duration_sec} seconds"

        self.logger.info("scan_plan_built", targets=valid_count, duration=duration_str)

        return {
            "scan_plan": scan_plan,
            "targets_validated": targets_validated,
            "schedule_config": schedule_config,
            "estimated_duration": duration_str,
        }
