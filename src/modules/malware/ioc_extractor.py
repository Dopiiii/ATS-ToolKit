"""Indicator of Compromise (IOC) extraction module.

Extract IOCs from text data or files: IP addresses, domains, URLs, email addresses,
file hashes, file paths, registry keys, CVE IDs, and Bitcoin addresses.
Supports defanging indicators for safe sharing in reports.
"""

import asyncio
import os
import re
from typing import Any, Dict, List, Tuple
from collections import OrderedDict

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

# IOC extraction patterns
IOC_PATTERNS: Dict[str, re.Pattern] = {
    # Network IOCs
    "ipv4": re.compile(
        r"\b(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\b"
    ),
    "ipv6": re.compile(
        r"\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\b"
        r"|\b(?:[0-9a-fA-F]{1,4}:){1,7}:\b"
        r"|\b(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}\b"
        r"|\b::(?:ffff:)?(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\b"
    ),
    "domain": re.compile(
        r"\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+"
        r"(?:com|net|org|edu|gov|mil|int|io|co|me|info|biz|name|mobi|pro|aero|coop|museum"
        r"|tv|cc|us|uk|ca|de|fr|au|ru|cn|jp|br|in|it|nl|es|se|no|fi|dk|pl|cz|at|ch|be"
        r"|pt|ie|nz|za|mx|ar|cl|kr|tw|sg|hk|th|my|ph|vn|id|xyz|top|club|online|site"
        r"|pw|tk|ml|ga|cf|gq|win|bid|review|stream|trade|date|racing|science|party)\b",
        re.IGNORECASE,
    ),
    "url": re.compile(
        r"(?:https?|ftp|ftps)://[^\s\"'<>\x00]{5,500}",
        re.IGNORECASE,
    ),
    # Email IOCs
    "email": re.compile(
        r"\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b",
        re.IGNORECASE,
    ),
    # File hash IOCs
    "md5": re.compile(r"\b[0-9a-fA-F]{32}\b"),
    "sha1": re.compile(r"\b[0-9a-fA-F]{40}\b"),
    "sha256": re.compile(r"\b[0-9a-fA-F]{64}\b"),
    # File paths
    "windows_path": re.compile(
        r"[A-Za-z]:\\(?:[^\\\s\"<>|*?:]{1,100}\\)*[^\\\s\"<>|*?:]{1,100}"
    ),
    "linux_path": re.compile(
        r"(?:/(?:usr|etc|var|tmp|opt|home|root|bin|sbin|lib|dev|proc|sys|mnt|media)"
        r"(?:/[a-zA-Z0-9._-]{1,100}){1,15})"
    ),
    # Registry keys
    "registry_key": re.compile(
        r"(?:HKEY_(?:LOCAL_MACHINE|CURRENT_USER|CLASSES_ROOT|USERS|CURRENT_CONFIG)"
        r"|HKLM|HKCU|HKCR|HKU|HKCC)\\[^\s\"]{5,250}",
        re.IGNORECASE,
    ),
    # CVE IDs
    "cve": re.compile(r"\bCVE-\d{4}-\d{4,7}\b", re.IGNORECASE),
    # Bitcoin addresses (legacy P2PKH/P2SH and Bech32)
    "bitcoin_address": re.compile(
        r"\b(?:[13][a-km-zA-HJ-NP-Z1-9]{25,34}|bc1[a-zA-HJ-NP-Z0-9]{25,90})\b"
    ),
}

# IOC type groupings for filtering
IOC_GROUPS: Dict[str, List[str]] = {
    "network": ["ipv4", "ipv6", "domain", "url"],
    "file": ["md5", "sha1", "sha256", "windows_path", "linux_path"],
    "email": ["email"],
    "all": list(IOC_PATTERNS.keys()),
}

# Known false positive patterns to filter
FALSE_POSITIVE_IPS = {"0.0.0.0", "255.255.255.255", "127.0.0.1", "192.168.0.0"}
FALSE_POSITIVE_DOMAINS = {"example.com", "example.org", "example.net", "localhost"}


class IocExtractorModule(AtsModule):
    """Extract Indicators of Compromise from text or file data."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="ioc_extractor",
            category=ModuleCategory.MALWARE,
            description="Extract IOCs (IPs, domains, URLs, hashes, emails, file paths, registry keys, CVEs, Bitcoin addresses) from text or files",
            version="1.0.0",
            parameters=[
                Parameter(
                    name="data",
                    type=ParameterType.STRING,
                    description="Text data or file path to extract IOCs from",
                    required=True,
                ),
                Parameter(
                    name="ioc_types",
                    type=ParameterType.CHOICE,
                    description="Category of IOCs to extract",
                    required=False,
                    default="all",
                    choices=["all", "network", "file", "email"],
                ),
            ],
            outputs=[
                OutputField(name="iocs", type="dict", description="Extracted IOCs categorized by type"),
                OutputField(name="defanged", type="dict", description="Defanged IOCs for safe sharing"),
                OutputField(name="summary", type="dict", description="Counts and statistics"),
            ],
            tags=["malware", "ioc", "indicators", "threat-intel", "extraction"],
            author="ATS-Toolkit",
            dangerous=True,
        )

    def validate_inputs(self, config: Dict[str, Any]) -> Tuple[bool, str]:
        data = config.get("data", "").strip()
        if not data:
            return False, "data is required (text content or file path)"
        return True, ""

    def _load_data(self, data: str) -> str:
        """Load text from a file path or return the raw string."""
        if os.path.isfile(data):
            with open(data, "r", encoding="utf-8", errors="replace") as fh:
                return fh.read()
        return data

    def _refang_input(self, text: str) -> str:
        """Convert defanged indicators back to normal form for extraction."""
        text = text.replace("[.]", ".").replace("(dot)", ".")
        text = text.replace("hxxp", "http").replace("hxxps", "https")
        text = text.replace("[://]", "://").replace("[at]", "@").replace("[@]", "@")
        text = text.replace("[:]", ":")
        return text

    def _defang_indicator(self, ioc_type: str, value: str) -> str:
        """Defang an indicator for safe sharing."""
        if ioc_type in ("ipv4", "ipv6"):
            return value.replace(".", "[.]")
        elif ioc_type == "domain":
            return value.replace(".", "[.]")
        elif ioc_type == "url":
            result = value.replace("http://", "hxxp://").replace("https://", "hxxps://")
            # Also defang the domain portion
            parts = result.split("://", 1)
            if len(parts) == 2:
                host_rest = parts[1].split("/", 1)
                host_defanged = host_rest[0].replace(".", "[.]")
                result = parts[0] + "://" + host_defanged
                if len(host_rest) > 1:
                    result += "/" + host_rest[1]
            return result
        elif ioc_type == "email":
            return value.replace("@", "[@]").replace(".", "[.]")
        return value

    def _filter_false_positives(self, ioc_type: str, values: List[str]) -> List[str]:
        """Remove known false positives from extracted IOCs."""
        if ioc_type == "ipv4":
            return [v for v in values if v not in FALSE_POSITIVE_IPS and not v.startswith("0.")]
        elif ioc_type == "domain":
            return [v for v in values if v.lower() not in FALSE_POSITIVE_DOMAINS and len(v) > 4]
        elif ioc_type in ("md5", "sha1", "sha256"):
            # Filter out strings that are all the same character (like "0" * 32)
            return [v for v in values if len(set(v.lower())) > 3]
        return values

    def _extract_iocs(self, text: str, ioc_types: List[str]) -> Dict[str, List[str]]:
        """Extract all IOCs of specified types from text."""
        results: Dict[str, List[str]] = OrderedDict()

        for ioc_type in ioc_types:
            pattern = IOC_PATTERNS.get(ioc_type)
            if not pattern:
                continue

            matches = pattern.findall(text)
            unique = list(OrderedDict.fromkeys(matches))
            filtered = self._filter_false_positives(ioc_type, unique)

            # For hashes, disambiguate by length (sha256 matches could also match md5/sha1 patterns)
            if ioc_type == "md5" and "sha1" in ioc_types:
                filtered = [h for h in filtered if len(h) == 32]
            if ioc_type == "sha1" and "sha256" in ioc_types:
                filtered = [h for h in filtered if len(h) == 40]

            if filtered:
                results[ioc_type] = filtered

        return results

    async def execute(self, config: Dict[str, Any]) -> Dict[str, Any]:
        data_input = config["data"].strip()
        ioc_group = config.get("ioc_types", "all")

        self.logger.info("starting_ioc_extraction", group=ioc_group)

        loop = asyncio.get_event_loop()

        # Load and prepare text
        raw_text = await loop.run_in_executor(None, self._load_data, data_input)
        text = self._refang_input(raw_text)

        # Determine which IOC types to extract
        active_types = IOC_GROUPS.get(ioc_group, IOC_GROUPS["all"])

        # Extract IOCs
        iocs = self._extract_iocs(text, active_types)

        # Generate defanged versions
        defanged: Dict[str, List[str]] = {}
        for ioc_type, values in iocs.items():
            defanged_values = [self._defang_indicator(ioc_type, v) for v in values]
            if defanged_values:
                defanged[ioc_type] = defanged_values

        # Build summary
        total_iocs = sum(len(v) for v in iocs.values())
        summary = {
            "total_iocs": total_iocs,
            "source": data_input if not os.path.isfile(data_input) else f"file:{data_input}",
            "source_length": len(raw_text),
            "ioc_group_filter": ioc_group,
            "types_found": list(iocs.keys()),
            "counts_by_type": {k: len(v) for k, v in iocs.items()},
        }

        self.logger.info(
            "ioc_extraction_complete",
            total=total_iocs,
            types=len(iocs),
        )

        return {
            "iocs": dict(iocs),
            "defanged": defanged,
            "summary": summary,
        }
