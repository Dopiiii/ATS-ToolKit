"""Behavioral analysis simulation module for suspicious files.

Simulates sandbox-style analysis by examining file content for behavioral indicators:
embedded scripts, auto-execution triggers, anti-analysis techniques, and network
indicators. Defensive tool - no actual execution of suspicious code.
"""

import asyncio
import math
import os
import re
from typing import Any, Dict, List, Tuple

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

# Anti-analysis / evasion technique signatures
VM_DETECTION_STRINGS = [
    "VMware", "VirtualBox", "VBOX", "QEMU", "Xen", "Hyper-V",
    "vmtoolsd", "vmwaretray", "vboxservice", "vboxtray",
    "wine_get_unix_file_name", "sbiedll.dll",
    "\\\\REGISTRY\\\\MACHINE\\\\SOFTWARE\\\\VMware",
    "SYSTEM\\ControlSet001\\Services\\VBoxGuest",
    "Red Hat VirtIO", "KVMKVMKVM",
]

DEBUGGER_CHECKS = [
    "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "NtQueryInformationProcess",
    "OutputDebugString", "FindWindow", "EnumWindows",
    "OllyDbg", "x64dbg", "x32dbg", "IDA Pro", "Immunity",
    "int 3", "int 0x2d", "0xCC", "DebugBreak",
    "__debugbreak", "ptrace", "PTRACE_TRACEME",
]

SLEEP_EVASION_PATTERNS = [
    re.compile(rb"Sleep\s*\(\s*(\d{4,})\s*\)", re.IGNORECASE),
    re.compile(rb"time\.sleep\s*\(\s*(\d{2,})\s*\)", re.IGNORECASE),
    re.compile(rb"Thread\.Sleep\s*\(\s*(\d{4,})\s*\)", re.IGNORECASE),
    re.compile(rb"timeout\s+/t\s+(\d{2,})", re.IGNORECASE),
    re.compile(rb"Start-Sleep\s+(?:-Seconds\s+)?(\d{2,})", re.IGNORECASE),
]

AUTO_EXEC_TRIGGERS = [
    ("Auto_Open", "VBA auto-execution macro"),
    ("AutoOpen", "VBA auto-execution macro"),
    ("Document_Open", "VBA document open event"),
    ("Workbook_Open", "VBA workbook open event"),
    ("Auto_Close", "VBA auto-close macro"),
    ("<script", "Embedded script tag"),
    ("WScript.Shell", "Windows Script Host shell access"),
    ("Scripting.FileSystemObject", "File system object access"),
    ("schtasks /create", "Scheduled task creation"),
    ("crontab", "Linux cron job creation"),
    ("[autorun]", "Autorun.inf trigger"),
    ("CurrentVersion\\Run", "Registry run key persistence"),
    ("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run", "User startup persistence"),
    ("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run", "System startup persistence"),
]

SCRIPT_INDICATORS = {
    "powershell": [
        re.compile(rb"powershell(?:\.exe)?\s+.*-(?:enc|EncodedCommand)", re.IGNORECASE),
        re.compile(rb"Invoke-(?:Expression|WebRequest|RestMethod|Command)", re.IGNORECASE),
        re.compile(rb"IEX\s*\(", re.IGNORECASE),
        re.compile(rb"New-Object\s+System\.Net\.WebClient", re.IGNORECASE),
        re.compile(rb"DownloadString|DownloadFile|DownloadData", re.IGNORECASE),
    ],
    "vba_macro": [
        re.compile(rb"(?:Sub|Function)\s+\w+\(.*?\).*?(?:Shell|CreateObject|WScript)", re.IGNORECASE | re.DOTALL),
        re.compile(rb"CreateObject\s*\(\s*[\"'](?:WScript\.Shell|Scripting\.FileSystemObject|ADODB\.Stream)", re.IGNORECASE),
        re.compile(rb"(?:Environ|GetObject|CallByName)\s*\(", re.IGNORECASE),
    ],
    "batch_cmd": [
        re.compile(rb"@echo\s+off", re.IGNORECASE),
        re.compile(rb"cmd(?:\.exe)?\s+/c\s+", re.IGNORECASE),
        re.compile(rb"certutil\s+-(?:urlcache|decode|encode)", re.IGNORECASE),
        re.compile(rb"bitsadmin\s+/transfer", re.IGNORECASE),
    ],
    "bash_shell": [
        re.compile(rb"#!/bin/(?:bash|sh|zsh)"),
        re.compile(rb"(?:curl|wget)\s+.*?(?:\|\s*(?:bash|sh)|>\s*/tmp/)", re.IGNORECASE),
        re.compile(rb"chmod\s+\+x\s+", re.IGNORECASE),
        re.compile(rb"(?:nc|ncat|netcat)\s+-[elp]", re.IGNORECASE),
    ],
}

NETWORK_PATTERNS = {
    "urls": re.compile(rb"https?://[^\s\"'<>\x00]{5,200}", re.IGNORECASE),
    "ipv4": re.compile(rb"\b(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\b"),
    "domains": re.compile(rb"\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+(?:com|net|org|io|cc|ru|cn|tk|xyz|top|info|biz|pw|club)\b", re.IGNORECASE),
    "ports": re.compile(rb":(\d{2,5})(?:\s|/|$)"),
}


class SandboxAnalyzerModule(AtsModule):
    """Behavioral analysis simulation for suspicious files."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="sandbox_analyzer",
            category=ModuleCategory.MALWARE,
            description="Behavioral analysis simulation: detect scripts, auto-execution triggers, anti-analysis techniques, and network indicators",
            version="1.0.0",
            parameters=[
                Parameter(
                    name="file_path",
                    type=ParameterType.FILE,
                    description="Path to the suspicious file to analyze",
                    required=True,
                ),
                Parameter(
                    name="timeout",
                    type=ParameterType.INTEGER,
                    description="Analysis timeout in seconds",
                    required=False,
                    default=30,
                    min_value=5,
                    max_value=300,
                ),
                Parameter(
                    name="monitor_level",
                    type=ParameterType.CHOICE,
                    description="Monitoring depth level",
                    required=False,
                    default="basic",
                    choices=["basic", "full"],
                ),
            ],
            outputs=[
                OutputField(name="behavioral_indicators", type="list", description="Detected behavioral patterns and triggers"),
                OutputField(name="network_indicators", type="dict", description="Embedded network indicators (URLs, IPs, domains)"),
                OutputField(name="evasion_techniques", type="list", description="Detected anti-analysis and evasion techniques"),
                OutputField(name="risk_score", type="dict", description="Computed risk score and assessment"),
            ],
            tags=["malware", "sandbox", "behavioral-analysis", "evasion-detection"],
            author="ATS-Toolkit",
            dangerous=True,
        )

    def validate_inputs(self, config: Dict[str, Any]) -> Tuple[bool, str]:
        file_path = config.get("file_path", "").strip()
        if not file_path:
            return False, "file_path is required"
        if not os.path.isfile(file_path):
            return False, f"File not found: {file_path}"
        return True, ""

    def _detect_behavioral_indicators(self, data: bytes, is_full: bool) -> List[Dict[str, Any]]:
        """Detect auto-execution triggers and embedded script patterns."""
        indicators: List[Dict[str, Any]] = []

        # Check auto-execution triggers
        text = data.decode("utf-8", errors="replace")
        for trigger, description in AUTO_EXEC_TRIGGERS:
            if trigger.lower() in text.lower():
                indicators.append({
                    "type": "auto_execution",
                    "trigger": trigger,
                    "description": description,
                    "severity": "high",
                })

        # Detect embedded script types
        for script_type, patterns in SCRIPT_INDICATORS.items():
            for pattern in patterns:
                matches = pattern.findall(data)
                if matches:
                    sample = matches[0][:200] if matches[0] else b""
                    indicators.append({
                        "type": "embedded_script",
                        "script_type": script_type,
                        "sample": sample.decode("utf-8", errors="replace"),
                        "occurrences": len(matches),
                        "severity": "high" if script_type in ("powershell", "vba_macro") else "medium",
                    })
                    break  # One detection per script type is sufficient

        # Full monitoring: check for process manipulation patterns
        if is_full:
            process_patterns = [
                ("process_creation", rb"(?:CreateProcess|ShellExecute|WinExec|system\s*\()", "Process creation API"),
                ("process_injection", rb"(?:VirtualAllocEx|WriteProcessMemory|CreateRemoteThread)", "Process injection APIs"),
                ("privilege_escalation", rb"(?:AdjustTokenPrivileges|SeDebugPrivilege|runas\s+/user)", "Privilege escalation attempt"),
                ("file_manipulation", rb"(?:DeleteFile|MoveFile|CopyFile|remove\s*\(|unlink\s*\()", "File manipulation operations"),
                ("service_manipulation", rb"(?:CreateService|StartService|sc\s+create|systemctl)", "Service creation/manipulation"),
            ]
            for name, pattern, desc in process_patterns:
                if re.search(pattern, data, re.IGNORECASE):
                    indicators.append({
                        "type": name,
                        "description": desc,
                        "severity": "high",
                    })

        return indicators

    def _detect_evasion_techniques(self, data: bytes) -> List[Dict[str, Any]]:
        """Detect anti-analysis and sandbox evasion techniques."""
        techniques: List[Dict[str, Any]] = []

        # VM detection strings
        text_lower = data.lower()
        found_vm = []
        for vm_str in VM_DETECTION_STRINGS:
            if vm_str.lower().encode("utf-8") in text_lower:
                found_vm.append(vm_str)
        if found_vm:
            techniques.append({
                "type": "vm_detection",
                "detail": f"VM/sandbox detection strings found: {', '.join(found_vm[:5])}",
                "strings": found_vm,
                "severity": "high",
            })

        # Debugger detection
        found_dbg = []
        for dbg_str in DEBUGGER_CHECKS:
            if dbg_str.encode("utf-8") in data:
                found_dbg.append(dbg_str)
        if found_dbg:
            techniques.append({
                "type": "debugger_detection",
                "detail": f"Anti-debugging references found: {', '.join(found_dbg[:5])}",
                "strings": found_dbg,
                "severity": "high",
            })

        # Sleep-based evasion (large sleep values to outlast sandboxes)
        for pattern in SLEEP_EVASION_PATTERNS:
            for m in pattern.finditer(data):
                try:
                    sleep_val = int(m.group(1))
                    if sleep_val >= 30:
                        techniques.append({
                            "type": "sleep_evasion",
                            "detail": f"Long sleep/delay detected: {sleep_val} (may be seconds or milliseconds)",
                            "value": sleep_val,
                            "severity": "medium",
                        })
                        break
                except (ValueError, IndexError):
                    pass

        # Environment checks (sandbox fingerprinting)
        env_checks = [
            (rb"GetSystemInfo|SYSTEM_INFO", "System information enumeration"),
            (rb"GetComputerName|GetUserName", "Computer/user name enumeration"),
            (rb"NumberOfProcessors|TotalPhysicalMemory", "Hardware specification check"),
            (rb"GetCursorPos|GetLastInputInfo", "User interaction detection"),
            (rb"SELECT\s+\*\s+FROM\s+Win32_", "WMI query for system enumeration"),
        ]
        for pattern, desc in env_checks:
            if re.search(pattern, data, re.IGNORECASE):
                techniques.append({
                    "type": "environment_check",
                    "detail": desc,
                    "severity": "low",
                })

        return techniques

    def _extract_network_indicators(self, data: bytes) -> Dict[str, Any]:
        """Extract network-related indicators from file data."""
        indicators: Dict[str, Any] = {}

        for name, pattern in NETWORK_PATTERNS.items():
            matches = pattern.findall(data)
            unique = list(set(m.decode("utf-8", errors="replace") if isinstance(m, bytes) else m for m in matches))
            # Filter out common false positives
            if name == "ipv4":
                unique = [ip for ip in unique if not ip.startswith(("0.", "127.", "255."))]
            if name == "ports":
                unique = [p for p in unique if 1 <= int(p) <= 65535]
            if unique:
                indicators[name] = unique[:50]

        indicators["total_network_iocs"] = sum(len(v) for v in indicators.values() if isinstance(v, list))
        return indicators

    def _compute_risk_score(self, behavioral: List, evasion: List, network: Dict) -> Dict[str, Any]:
        """Compute an overall risk score from all findings."""
        score = 0
        severity_weights = {"critical": 25, "high": 15, "medium": 8, "low": 3}

        for item in behavioral:
            score += severity_weights.get(item.get("severity", "low"), 3)
        for item in evasion:
            score += severity_weights.get(item.get("severity", "low"), 3)

        network_count = network.get("total_network_iocs", 0)
        score += min(network_count * 2, 20)

        # Cap at 100
        score = min(score, 100)

        if score >= 75:
            assessment = "CRITICAL - Strong indicators of malicious behavior"
        elif score >= 50:
            assessment = "HIGH - Multiple suspicious indicators detected"
        elif score >= 25:
            assessment = "MEDIUM - Some suspicious patterns found, further analysis recommended"
        elif score > 0:
            assessment = "LOW - Minor indicators found, likely benign"
        else:
            assessment = "CLEAN - No significant indicators detected"

        return {
            "score": score,
            "max_score": 100,
            "assessment": assessment,
            "behavioral_count": len(behavioral),
            "evasion_count": len(evasion),
            "network_ioc_count": network_count,
        }

    async def execute(self, config: Dict[str, Any]) -> Dict[str, Any]:
        file_path = config["file_path"].strip()
        monitor_level = config.get("monitor_level", "basic")
        is_full = monitor_level == "full"

        self.logger.info("starting_sandbox_analysis", file=file_path, level=monitor_level)

        loop = asyncio.get_event_loop()

        def _read_file() -> bytes:
            with open(file_path, "rb") as fh:
                return fh.read()

        data = await loop.run_in_executor(None, _read_file)

        # Run all detection passes
        behavioral = self._detect_behavioral_indicators(data, is_full)
        evasion = self._detect_evasion_techniques(data)
        network = self._extract_network_indicators(data)
        risk = self._compute_risk_score(behavioral, evasion, network)

        self.logger.info(
            "sandbox_analysis_complete",
            risk_score=risk["score"],
            behavioral=len(behavioral),
            evasion=len(evasion),
        )

        return {
            "file_path": file_path,
            "file_size": len(data),
            "behavioral_indicators": behavioral,
            "network_indicators": network,
            "evasion_techniques": evasion,
            "risk_score": risk,
        }
