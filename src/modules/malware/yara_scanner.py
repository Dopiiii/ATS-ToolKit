"""YARA-like pattern scanner for malware detection.

Pure Python implementation of pattern matching against built-in rule definitions.
Supports hex patterns, string patterns, and regex matching without requiring
the yara-python library. Defensive tool for file and data scanning.
"""

import asyncio
import os
import re
from typing import Any, Dict, List, Tuple, Optional

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)


class YaraRule:
    """A single YARA-like rule with patterns and metadata."""

    def __init__(self, name: str, category: str, description: str,
                 severity: str, patterns: List[Dict[str, Any]]):
        self.name = name
        self.category = category
        self.description = description
        self.severity = severity
        self.patterns = patterns  # list of {"id": str, "type": "hex"|"string"|"regex", "value": str}


# Built-in rule definitions organized by ruleset
BUILTIN_RULES: Dict[str, List[YaraRule]] = {
    "web_shells": [
        YaraRule("WebShell_PHP_Generic", "web_shells", "Generic PHP web shell patterns", "high", [
            {"id": "s1", "type": "string", "value": "eval($_POST"},
            {"id": "s2", "type": "string", "value": "eval($_GET"},
            {"id": "s3", "type": "string", "value": "eval($_REQUEST"},
            {"id": "s4", "type": "string", "value": "assert($_POST"},
            {"id": "s5", "type": "regex", "value": r"(?:eval|assert|system|passthru|exec|shell_exec)\s*\(\s*(?:\$_(?:GET|POST|REQUEST|COOKIE)|base64_decode)"},
        ]),
        YaraRule("WebShell_JSP_Generic", "web_shells", "Generic JSP web shell patterns", "high", [
            {"id": "s1", "type": "string", "value": "Runtime.getRuntime().exec"},
            {"id": "s2", "type": "string", "value": "ProcessBuilder"},
            {"id": "s3", "type": "regex", "value": r"request\.getParameter\s*\(.*?\)\s*.*?(?:exec|Runtime|ProcessBuilder)"},
        ]),
        YaraRule("WebShell_ASPX_Generic", "web_shells", "Generic ASPX web shell patterns", "high", [
            {"id": "s1", "type": "string", "value": "Process.Start"},
            {"id": "s2", "type": "string", "value": "cmd.exe /c"},
            {"id": "s3", "type": "regex", "value": r"(?:Request\.(?:Form|QueryString|Params)).*(?:Process\.Start|Diagnostics\.Process)"},
        ]),
    ],
    "ransomware": [
        YaraRule("Ransomware_FileEncryption", "ransomware", "File encryption patterns typical of ransomware", "critical", [
            {"id": "s1", "type": "string", "value": "Your files have been encrypted"},
            {"id": "s2", "type": "string", "value": "pay the ransom"},
            {"id": "s3", "type": "string", "value": "bitcoin wallet"},
            {"id": "s4", "type": "regex", "value": r"(?:AES|RSA|ChaCha20).*(?:encrypt|cipher)"},
        ]),
        YaraRule("Ransomware_Extension_Rename", "ransomware", "Ransomware file extension modification patterns", "high", [
            {"id": "s1", "type": "regex", "value": r"\.(?:locked|encrypted|crypt|enc|cry|pays)\b"},
            {"id": "s2", "type": "string", "value": "README_DECRYPT"},
            {"id": "s3", "type": "string", "value": "HOW_TO_RECOVER"},
            {"id": "s4", "type": "string", "value": "DECRYPT_INSTRUCTIONS"},
        ]),
        YaraRule("Ransomware_CryptoAPI", "ransomware", "Windows Crypto API usage for bulk encryption", "high", [
            {"id": "h1", "type": "hex", "value": "4372797074456e6372797074"},  # CryptEncrypt
            {"id": "h2", "type": "hex", "value": "43727970744465637279707446696e616c"},  # CryptDecryptFinal
            {"id": "s1", "type": "string", "value": "CryptGenKey"},
            {"id": "s2", "type": "string", "value": "CryptImportKey"},
        ]),
    ],
    "trojans": [
        YaraRule("Trojan_Keylogger", "trojans", "Keylogger behavior patterns", "high", [
            {"id": "s1", "type": "string", "value": "GetAsyncKeyState"},
            {"id": "s2", "type": "string", "value": "SetWindowsHookEx"},
            {"id": "s3", "type": "string", "value": "GetKeyState"},
            {"id": "s4", "type": "regex", "value": r"(?:keylog|keystroke|key_press|keyboard_hook)"},
        ]),
        YaraRule("Trojan_Downloader", "trojans", "Downloader trojan patterns", "high", [
            {"id": "s1", "type": "string", "value": "URLDownloadToFile"},
            {"id": "s2", "type": "string", "value": "InternetOpenUrl"},
            {"id": "s3", "type": "regex", "value": r"(?:wget|curl|Invoke-WebRequest|DownloadFile|DownloadString)\s"},
        ]),
        YaraRule("Trojan_ProcessInjection", "trojans", "Process injection technique patterns", "critical", [
            {"id": "s1", "type": "string", "value": "VirtualAllocEx"},
            {"id": "s2", "type": "string", "value": "WriteProcessMemory"},
            {"id": "s3", "type": "string", "value": "CreateRemoteThread"},
            {"id": "s4", "type": "string", "value": "NtUnmapViewOfSection"},
        ]),
        YaraRule("Trojan_Persistence", "trojans", "Persistence mechanism patterns", "medium", [
            {"id": "s1", "type": "string", "value": "CurrentVersion\\Run"},
            {"id": "s2", "type": "string", "value": "schtasks /create"},
            {"id": "s3", "type": "string", "value": "startup folder"},
            {"id": "s4", "type": "regex", "value": r"(?:HKLM|HKCU)\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\(?:Run|RunOnce)"},
        ]),
    ],
    "default": [
        YaraRule("Suspicious_PowerShell", "default", "Suspicious PowerShell patterns", "medium", [
            {"id": "s1", "type": "regex", "value": r"-(?:enc|EncodedCommand)\s+[A-Za-z0-9+/=]{20,}"},
            {"id": "s2", "type": "string", "value": "Invoke-Expression"},
            {"id": "s3", "type": "string", "value": "IEX("},
            {"id": "s4", "type": "string", "value": "bypass -nop"},
            {"id": "s5", "type": "string", "value": "hidden -ep bypass"},
        ]),
        YaraRule("Suspicious_ShellCode", "default", "Potential shellcode patterns", "high", [
            {"id": "h1", "type": "hex", "value": "fc4883e4f0e8"},  # Common x64 shellcode stub
            {"id": "h2", "type": "hex", "value": "fce8820000"},    # x86 shellcode stub
            {"id": "h3", "type": "hex", "value": "31c0505068"},    # push-based shellcode
        ]),
        YaraRule("Suspicious_Obfuscation", "default", "Code obfuscation techniques", "medium", [
            {"id": "s1", "type": "regex", "value": r"(?:chr|Chr|CHR)\s*\(\s*\d+\s*\)(?:\s*[+&.]\s*(?:chr|Chr|CHR)\s*\(\s*\d+\s*\)){5,}"},
            {"id": "s2", "type": "regex", "value": r"(?:fromCharCode|String\.fromCharCode)\s*\(\s*(?:\d+\s*,\s*){5,}"},
            {"id": "s3", "type": "string", "value": "base64_decode(base64_decode"},
        ]),
    ],
}


class YaraScannerModule(AtsModule):
    """Scan files or data against YARA-like pattern rules."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="yara_scanner",
            category=ModuleCategory.MALWARE,
            description="Scan files/data against YARA-like rules using a pure Python pattern matching engine with built-in rulesets",
            version="1.0.0",
            parameters=[
                Parameter(
                    name="target",
                    type=ParameterType.STRING,
                    description="File path or raw data string to scan",
                    required=True,
                ),
                Parameter(
                    name="ruleset",
                    type=ParameterType.CHOICE,
                    description="Rule category to scan against",
                    required=False,
                    default="default",
                    choices=["default", "web_shells", "ransomware", "trojans", "all"],
                ),
            ],
            outputs=[
                OutputField(name="matches", type="list", description="List of matched rules with details"),
                OutputField(name="scan_summary", type="dict", description="Summary of scan results"),
                OutputField(name="rules_checked", type="integer", description="Total rules evaluated"),
            ],
            tags=["malware", "yara", "pattern-matching", "scanning", "detection"],
            author="ATS-Toolkit",
            dangerous=True,
        )

    def validate_inputs(self, config: Dict[str, Any]) -> Tuple[bool, str]:
        target = config.get("target", "").strip()
        if not target:
            return False, "target is required (file path or data string)"
        return True, ""

    def _load_target_data(self, target: str) -> Tuple[bytes, str]:
        """Load scan data from file path or raw string."""
        if os.path.isfile(target):
            with open(target, "rb") as fh:
                return fh.read(), "file"
        return target.encode("utf-8", errors="replace"), "string"

    def _match_hex_pattern(self, data: bytes, hex_str: str) -> List[int]:
        """Match a hex pattern against binary data, returning offsets."""
        try:
            pattern_bytes = bytes.fromhex(hex_str)
        except ValueError:
            return []
        offsets = []
        start = 0
        while True:
            idx = data.find(pattern_bytes, start)
            if idx == -1:
                break
            offsets.append(idx)
            start = idx + 1
        return offsets

    def _match_string_pattern(self, data: bytes, pattern_str: str) -> List[int]:
        """Match a literal string pattern (case-insensitive) against data."""
        target = pattern_str.encode("utf-8", errors="replace")
        target_lower = target.lower()
        data_lower = data.lower()
        offsets = []
        start = 0
        while True:
            idx = data_lower.find(target_lower, start)
            if idx == -1:
                break
            offsets.append(idx)
            start = idx + 1
        return offsets

    def _match_regex_pattern(self, data: bytes, regex_str: str) -> List[Tuple[int, str]]:
        """Match a regex pattern against data (decoded as UTF-8)."""
        try:
            text = data.decode("utf-8", errors="replace")
        except Exception:
            text = data.decode("latin-1", errors="replace")
        results = []
        try:
            for m in re.finditer(regex_str, text, re.IGNORECASE | re.DOTALL):
                results.append((m.start(), m.group()[:200]))
        except re.error:
            pass
        return results

    def _evaluate_rule(self, rule: YaraRule, data: bytes) -> Optional[Dict[str, Any]]:
        """Evaluate a single rule against data. Returns match info or None."""
        matched_patterns: List[Dict[str, Any]] = []

        for pattern in rule.patterns:
            pid = pattern["id"]
            ptype = pattern["type"]
            pvalue = pattern["value"]

            if ptype == "hex":
                offsets = self._match_hex_pattern(data, pvalue)
                if offsets:
                    matched_patterns.append({
                        "id": pid, "type": ptype,
                        "matched_at": offsets[:20],
                        "value": pvalue,
                    })
            elif ptype == "string":
                offsets = self._match_string_pattern(data, pvalue)
                if offsets:
                    matched_patterns.append({
                        "id": pid, "type": ptype,
                        "matched_at": offsets[:20],
                        "value": pvalue,
                    })
            elif ptype == "regex":
                results = self._match_regex_pattern(data, pvalue)
                if results:
                    matched_patterns.append({
                        "id": pid, "type": ptype,
                        "matched_at": [r[0] for r in results[:20]],
                        "matched_strings": [r[1] for r in results[:10]],
                        "value": pvalue,
                    })

        if matched_patterns:
            return {
                "rule_name": rule.name,
                "category": rule.category,
                "description": rule.description,
                "severity": rule.severity,
                "matched_patterns": matched_patterns,
                "patterns_matched": len(matched_patterns),
                "patterns_total": len(rule.patterns),
            }
        return None

    async def execute(self, config: Dict[str, Any]) -> Dict[str, Any]:
        target = config["target"].strip()
        ruleset = config.get("ruleset", "default")

        self.logger.info("starting_yara_scan", target=target[:100], ruleset=ruleset)

        loop = asyncio.get_event_loop()
        data, source_type = await loop.run_in_executor(None, self._load_target_data, target)

        # Select rules
        if ruleset == "all":
            rules: List[YaraRule] = []
            for category_rules in BUILTIN_RULES.values():
                rules.extend(category_rules)
        else:
            rules = BUILTIN_RULES.get(ruleset, BUILTIN_RULES["default"])

        # Evaluate all rules
        matches: List[Dict[str, Any]] = []

        def _scan():
            for rule in rules:
                result = self._evaluate_rule(rule, data)
                if result:
                    matches.append(result)

        await loop.run_in_executor(None, _scan)

        # Build summary
        severity_counts: Dict[str, int] = {}
        for m in matches:
            sev = m["severity"]
            severity_counts[sev] = severity_counts.get(sev, 0) + 1

        scan_summary = {
            "source_type": source_type,
            "source": target if source_type == "file" else f"<string data, {len(data)} bytes>",
            "data_size": len(data),
            "ruleset": ruleset,
            "total_matches": len(matches),
            "severity_breakdown": severity_counts,
            "highest_severity": max(severity_counts.keys(), key=lambda s: {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(s, 0)) if severity_counts else "none",
        }

        self.logger.info(
            "yara_scan_complete",
            matches=len(matches),
            rules_checked=len(rules),
        )

        return {
            "matches": matches,
            "scan_summary": scan_summary,
            "rules_checked": len(rules),
        }
