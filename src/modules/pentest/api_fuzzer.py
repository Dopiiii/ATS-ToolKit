"""API endpoint fuzzer.

Discovers and tests API endpoints by fuzzing common paths, HTTP methods,
and content types to find hidden or misconfigured API surfaces.
"""

import asyncio
from typing import Any
from urllib.parse import urljoin

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

COMMON_API_PATHS = [
    "api", "api/v1", "api/v2", "api/v3", "rest", "rest/v1",
    "graphql", "graphiql", "playground",
    "swagger.json", "swagger/v1/swagger.json", "swagger-ui.html",
    "openapi.json", "openapi.yaml", "api-docs", "api-docs.json",
    "docs", "redoc", "api/docs",
    "health", "healthz", "health/live", "health/ready",
    "status", "info", "version", "ping",
    "metrics", "prometheus/metrics",
    "admin", "admin/api", "internal", "internal/api",
    "debug", "debug/vars", "debug/pprof",
    "console", "actuator", "actuator/env", "actuator/health",
    "env", "config", "configuration",
    ".well-known/openid-configuration", ".well-known/jwks.json",
    "token", "oauth/token", "auth/token", "login", "register",
    "users", "user", "accounts", "profile", "me",
    "search", "query", "data", "export", "import",
    "upload", "uploads", "files", "download",
    "webhook", "webhooks", "callback", "events",
    "ws", "websocket", "socket.io",
    "sitemap.xml", "robots.txt", ".env",
]

HTTP_METHODS = ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"]

CONTENT_TYPES = [
    "application/json",
    "application/xml",
    "application/x-www-form-urlencoded",
    "text/plain",
    "multipart/form-data",
]

INTERESTING_STATUS_CODES = {200, 201, 204, 301, 302, 307, 401, 403, 405, 500, 502, 503}


class ApiFuzzerModule(AtsModule):
    """Discover and test API endpoints through fuzzing."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="api_fuzzer",
            category=ModuleCategory.PENTEST,
            description="Fuzz and discover API endpoints by testing common paths, HTTP methods, and content types",
            version="1.0.0",
            parameters=[
                Parameter(name="base_url", type=ParameterType.URL,
                          description="Base URL of the target application", required=True),
                Parameter(name="methods", type=ParameterType.CHOICE,
                          description="HTTP methods to test",
                          choices=["all", "get", "post"], default="all"),
                Parameter(name="fuzz_paths", type=ParameterType.BOOLEAN,
                          description="Fuzz common API paths",
                          default=True),
            ],
            outputs=[
                OutputField(name="discovered_endpoints", type="list",
                            description="Discovered API endpoints with details"),
                OutputField(name="anomalous_responses", type="list",
                            description="Endpoints returning unexpected or error responses"),
                OutputField(name="summary", type="dict", description="Fuzzing summary"),
            ],
            tags=["pentest", "api", "fuzzing", "web", "enumeration", "rest"],
            author="ATS-Toolkit",
            dangerous=False,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        url = config.get("base_url", "").strip()
        if not url:
            return False, "Base URL is required"
        if not url.startswith(("http://", "https://")):
            return False, "Base URL must start with http:// or https://"
        return True, ""

    def _get_methods(self, method_choice: str) -> list[str]:
        """Get list of HTTP methods to test."""
        if method_choice == "get":
            return ["GET", "HEAD"]
        elif method_choice == "post":
            return ["POST"]
        return HTTP_METHODS

    async def _probe_endpoint(self, session: aiohttp.ClientSession, url: str,
                               method: str, semaphore: asyncio.Semaphore,
                               content_type: str | None = None) -> dict[str, Any] | None:
        """Probe a single endpoint with the given method."""
        async with semaphore:
            headers: dict[str, str] = {}
            data = None
            if content_type:
                headers["Content-Type"] = content_type
            if method in ("POST", "PUT", "PATCH"):
                if content_type == "application/json":
                    data = '{"test": true}'
                elif content_type == "application/xml":
                    data = '<test>true</test>'
                else:
                    data = "test=true"

            try:
                async with session.request(
                    method, url, headers=headers, data=data,
                    timeout=aiohttp.ClientTimeout(total=8),
                    ssl=False, allow_redirects=False,
                ) as resp:
                    if resp.status not in INTERESTING_STATUS_CODES:
                        return None

                    body = ""
                    try:
                        body = await resp.text(errors="replace")
                        body = body[:500]
                    except Exception:
                        pass

                    result: dict[str, Any] = {
                        "url": url,
                        "method": method,
                        "status_code": resp.status,
                        "content_type": resp.headers.get("Content-Type", ""),
                        "content_length": resp.content_length or len(body),
                    }

                    if content_type:
                        result["request_content_type"] = content_type

                    # Detect API-like responses
                    resp_ct = resp.headers.get("Content-Type", "").lower()
                    if "json" in resp_ct or "xml" in resp_ct:
                        result["api_response"] = True
                        result["body_preview"] = body[:200]
                    elif resp.status in (401, 403):
                        result["auth_required"] = True

                    if resp.status in (301, 302, 307):
                        result["redirect_to"] = resp.headers.get("Location", "")

                    return result
            except (aiohttp.ClientError, asyncio.TimeoutError):
                return None

    async def _get_baseline(self, session: aiohttp.ClientSession,
                             base_url: str) -> dict[str, Any]:
        """Get baseline response for non-existent path."""
        fake_url = urljoin(base_url.rstrip("/") + "/", "nonexistent_ats_probe_84721")
        try:
            async with session.get(fake_url, timeout=aiohttp.ClientTimeout(total=8),
                                   ssl=False, allow_redirects=False) as resp:
                body = await resp.text(errors="replace")
                return {"status": resp.status, "length": len(body)}
        except (aiohttp.ClientError, asyncio.TimeoutError):
            return {"status": 404, "length": 0}

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        base_url = config["base_url"].strip()
        method_choice = config.get("methods", "all")
        fuzz_paths = config.get("fuzz_paths", True)

        methods = self._get_methods(method_choice)
        self.logger.info("api_fuzz_start", url=base_url, methods=methods)

        semaphore = asyncio.Semaphore(15)
        discovered: list[dict[str, Any]] = []
        anomalous: list[dict[str, Any]] = []
        total_requests = 0

        connector = aiohttp.TCPConnector(limit=15, ssl=False)
        async with aiohttp.ClientSession(connector=connector) as session:
            baseline = await self._get_baseline(session, base_url)
            tasks = []

            if fuzz_paths:
                for path in COMMON_API_PATHS:
                    url = urljoin(base_url.rstrip("/") + "/", path)
                    # Test with GET first for discovery
                    tasks.append(self._probe_endpoint(session, url, "GET", semaphore))
                    total_requests += 1

            # Test methods on the base URL
            for method in methods:
                tasks.append(self._probe_endpoint(session, base_url, method, semaphore))
                total_requests += 1
                # Test with different content types for POST/PUT
                if method in ("POST", "PUT", "PATCH"):
                    for ct in CONTENT_TYPES[:3]:
                        tasks.append(self._probe_endpoint(session, base_url, method, semaphore, ct))
                        total_requests += 1

            results = await asyncio.gather(*tasks)

            seen_urls: set[str] = set()
            for result in results:
                if result is None:
                    continue
                # Filter out baseline-matching responses (soft 404s)
                if (result["status_code"] == baseline["status"]
                        and abs(result.get("content_length", 0) - baseline["length"]) < 50
                        and result["status_code"] not in (401, 403)):
                    continue

                url_key = f"{result['method']}:{result['url']}"
                if url_key in seen_urls:
                    continue
                seen_urls.add(url_key)

                discovered.append(result)
                if result["status_code"] >= 500:
                    anomalous.append(result)

            # For discovered endpoints, probe additional methods
            if method_choice == "all":
                extra_tasks = []
                for endpoint in discovered[:30]:  # limit to avoid excess requests
                    if endpoint["method"] == "GET":
                        for method in ["POST", "PUT", "DELETE", "OPTIONS"]:
                            extra_tasks.append(self._probe_endpoint(
                                session, endpoint["url"], method, semaphore
                            ))
                            total_requests += 1

                extra_results = await asyncio.gather(*extra_tasks)
                for result in extra_results:
                    if result and result["status_code"] not in (404, 405):
                        url_key = f"{result['method']}:{result['url']}"
                        if url_key not in seen_urls:
                            seen_urls.add(url_key)
                            discovered.append(result)
                            if result["status_code"] >= 500:
                                anomalous.append(result)

        discovered.sort(key=lambda x: x["url"])

        summary = {
            "base_url": base_url,
            "total_requests": total_requests,
            "endpoints_discovered": len(discovered),
            "anomalous_responses": len(anomalous),
            "auth_required_endpoints": sum(1 for d in discovered if d.get("auth_required")),
            "api_endpoints": sum(1 for d in discovered if d.get("api_response")),
        }

        self.logger.info("api_fuzz_complete", discovered=len(discovered), anomalous=len(anomalous))
        return {
            "discovered_endpoints": discovered,
            "anomalous_responses": anomalous,
            "summary": summary,
        }
