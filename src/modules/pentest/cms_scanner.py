"""CMS detection and vulnerability scanner.

Detects Content Management Systems (WordPress, Drupal, Joomla, etc.) by analyzing
fingerprints, meta tags, and known paths, then checks for common misconfigurations.
"""

import asyncio
import re
from typing import Any
from urllib.parse import urljoin

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

CMS_FINGERPRINTS: dict[str, dict[str, Any]] = {
    "WordPress": {
        "body_patterns": [r"wp-content/", r"wp-includes/", r"wp-json/"],
        "meta_patterns": [r'<meta[^>]*name=["\']generator["\'][^>]*content=["\']WordPress\s*([\d.]*)["\']'],
        "paths": ["wp-login.php", "wp-admin/", "wp-content/", "xmlrpc.php", "wp-json/wp/v2/"],
        "version_paths": ["wp-includes/version.php", "readme.html", "license.txt"],
    },
    "Drupal": {
        "body_patterns": [r"sites/default/files", r"Drupal\.settings", r"drupal\.js"],
        "meta_patterns": [r'<meta[^>]*name=["\']Generator["\'][^>]*content=["\']Drupal\s*([\d.]*)'],
        "paths": ["sites/default/", "core/misc/drupal.js", "user/login", "admin/"],
        "version_paths": ["CHANGELOG.txt", "core/CHANGELOG.txt"],
    },
    "Joomla": {
        "body_patterns": [r"/administrator/", r"com_content", r"Joomla!"],
        "meta_patterns": [r'<meta[^>]*name=["\']generator["\'][^>]*content=["\']Joomla!\s*([\d.]*)'],
        "paths": ["administrator/", "components/", "modules/", "templates/"],
        "version_paths": ["administrator/manifests/files/joomla.xml", "language/en-GB/en-GB.xml"],
    },
    "Magento": {
        "body_patterns": [r"Mage\.Cookies", r"/skin/frontend/", r"mage/cookies\.js"],
        "meta_patterns": [],
        "paths": ["admin/", "downloader/", "skin/frontend/", "js/mage/"],
        "version_paths": ["magento_version", "app/etc/local.xml"],
    },
    "Shopify": {
        "body_patterns": [r"cdn\.shopify\.com", r"Shopify\.theme"],
        "meta_patterns": [],
        "paths": ["admin/", "collections/", "products.json"],
        "version_paths": [],
    },
}

WORDPRESS_VULN_CHECKS = [
    {"path": "xmlrpc.php", "method": "POST",
     "body": '<?xml version="1.0"?><methodCall><methodName>system.listMethods</methodName></methodCall>',
     "indicator": "system.listMethods", "issue": "XML-RPC is enabled (brute-force and DDoS risk)"},
    {"path": "wp-json/wp/v2/users", "method": "GET", "body": None,
     "indicator": '"slug":', "issue": "User enumeration via REST API is exposed"},
    {"path": ".wp-config.php.swp", "method": "GET", "body": None,
     "indicator": "DB_", "issue": "Swap file for wp-config.php may be exposed"},
    {"path": "wp-content/debug.log", "method": "GET", "body": None,
     "indicator": "PHP", "issue": "Debug log file is publicly accessible"},
]


class CmsScannerModule(AtsModule):
    """Detect CMS type and scan for common misconfigurations."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="cms_scanner",
            category=ModuleCategory.PENTEST,
            description="Detect Content Management Systems and scan for common vulnerabilities and misconfigurations",
            version="1.0.0",
            parameters=[
                Parameter(name="url", type=ParameterType.URL,
                          description="Target URL to scan for CMS", required=True),
                Parameter(name="check_depth", type=ParameterType.CHOICE,
                          description="Detection only or full vulnerability scan",
                          choices=["detect", "scan"], default="detect"),
            ],
            outputs=[
                OutputField(name="cms_detected", type="string", description="Detected CMS name or 'unknown'"),
                OutputField(name="version", type="string", description="Detected CMS version if available"),
                OutputField(name="findings", type="list", description="Security findings and issues"),
            ],
            tags=["pentest", "cms", "wordpress", "drupal", "joomla", "web"],
            author="ATS-Toolkit",
            dangerous=False,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        url = config.get("url", "").strip()
        if not url:
            return False, "URL is required"
        if not url.startswith(("http://", "https://")):
            return False, "URL must start with http:// or https://"
        return True, ""

    async def _fetch_page(self, session: aiohttp.ClientSession, url: str) -> tuple[str, dict[str, str], int]:
        """Fetch a page and return body, headers, status."""
        try:
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=10),
                                   ssl=False, allow_redirects=True) as resp:
                body = await resp.text(errors="replace")
                headers = {k.lower(): v for k, v in resp.headers.items()}
                return body, headers, resp.status
        except (aiohttp.ClientError, asyncio.TimeoutError):
            return "", {}, 0

    async def _check_path(self, session: aiohttp.ClientSession, base_url: str,
                           path: str) -> tuple[int, str]:
        """Check if a specific path exists."""
        url = urljoin(base_url.rstrip("/") + "/", path)
        try:
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=8),
                                   ssl=False, allow_redirects=True) as resp:
                body = await resp.text(errors="replace")
                return resp.status, body[:2000]
        except (aiohttp.ClientError, asyncio.TimeoutError):
            return 0, ""

    def _detect_cms(self, body: str, headers: dict[str, str]) -> list[tuple[str, str]]:
        """Detect CMS from page body and headers."""
        detected = []
        for cms_name, fingerprint in CMS_FINGERPRINTS.items():
            score = 0
            version = ""
            for pattern in fingerprint["body_patterns"]:
                if re.search(pattern, body, re.IGNORECASE):
                    score += 1
            for pattern in fingerprint["meta_patterns"]:
                match = re.search(pattern, body, re.IGNORECASE)
                if match:
                    score += 2
                    if match.groups():
                        version = match.group(1)
            # Check common headers
            powered_by = headers.get("x-powered-by", "")
            if cms_name.lower() in powered_by.lower():
                score += 2
            if score >= 1:
                detected.append((cms_name, version))
        return detected

    async def _detect_version(self, session: aiohttp.ClientSession, base_url: str,
                               cms_name: str) -> str:
        """Try to detect the CMS version from known version files."""
        fingerprint = CMS_FINGERPRINTS.get(cms_name, {})
        for path in fingerprint.get("version_paths", []):
            status, body = await self._check_path(session, base_url, path)
            if status == 200 and body:
                # WordPress readme.html version
                match = re.search(r'Version\s+([\d.]+)', body, re.IGNORECASE)
                if match:
                    return match.group(1)
                # Joomla XML version
                match = re.search(r'<version>([\d.]+)</version>', body, re.IGNORECASE)
                if match:
                    return match.group(1)
                # Drupal changelog
                match = re.search(r'Drupal\s+([\d.]+)', body)
                if match:
                    return match.group(1)
        return ""

    async def _scan_wordpress(self, session: aiohttp.ClientSession,
                               base_url: str) -> list[dict[str, Any]]:
        """Run WordPress-specific vulnerability checks."""
        findings = []
        for check in WORDPRESS_VULN_CHECKS:
            url = urljoin(base_url.rstrip("/") + "/", check["path"])
            try:
                if check["method"] == "POST":
                    async with session.post(url, data=check["body"],
                                            timeout=aiohttp.ClientTimeout(total=10),
                                            ssl=False) as resp:
                        body = await resp.text(errors="replace")
                        if resp.status == 200 and check["indicator"] in body:
                            findings.append({
                                "path": check["path"], "issue": check["issue"],
                                "severity": "medium", "status_code": resp.status,
                            })
                else:
                    async with session.get(url, timeout=aiohttp.ClientTimeout(total=10),
                                           ssl=False) as resp:
                        body = await resp.text(errors="replace")
                        if resp.status == 200 and check["indicator"] in body:
                            findings.append({
                                "path": check["path"], "issue": check["issue"],
                                "severity": "medium", "status_code": resp.status,
                            })
            except (aiohttp.ClientError, asyncio.TimeoutError):
                continue

        # Check for directory listing in wp-content/uploads
        status, body = await self._check_path(session, base_url, "wp-content/uploads/")
        if status == 200 and ("<title>Index of" in body or "Parent Directory" in body):
            findings.append({
                "path": "wp-content/uploads/", "issue": "Uploads directory listing enabled",
                "severity": "medium", "status_code": status,
            })
        return findings

    async def _scan_generic(self, session: aiohttp.ClientSession, base_url: str,
                             cms_name: str) -> list[dict[str, Any]]:
        """Run generic path-existence checks for the detected CMS."""
        findings = []
        fingerprint = CMS_FINGERPRINTS.get(cms_name, {})
        for path in fingerprint.get("paths", []):
            status, body = await self._check_path(session, base_url, path)
            if status == 200:
                findings.append({
                    "path": path, "issue": f"CMS path accessible: /{path}",
                    "severity": "info", "status_code": status,
                })
            elif status == 403:
                findings.append({
                    "path": path, "issue": f"CMS path exists but forbidden: /{path}",
                    "severity": "low", "status_code": status,
                })
        return findings

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        url = config["url"].strip()
        check_depth = config.get("check_depth", "detect")

        self.logger.info("cms_scan_start", url=url, depth=check_depth)
        connector = aiohttp.TCPConnector(limit=10, ssl=False)

        async with aiohttp.ClientSession(connector=connector) as session:
            body, headers, status = await self._fetch_page(session, url)
            if status == 0:
                return {
                    "cms_detected": "unknown", "version": "",
                    "findings": [{"issue": "Could not connect to target", "severity": "error"}],
                }

            detected = self._detect_cms(body, headers)
            cms_name = detected[0][0] if detected else "unknown"
            version = detected[0][1] if detected else ""

            if not version and cms_name != "unknown":
                version = await self._detect_version(session, url, cms_name)

            findings: list[dict[str, Any]] = []

            if check_depth == "scan" and cms_name != "unknown":
                if cms_name == "WordPress":
                    findings = await self._scan_wordpress(session, url)
                findings.extend(await self._scan_generic(session, url, cms_name))

        self.logger.info("cms_scan_complete", cms=cms_name, version=version, findings=len(findings))
        return {
            "cms_detected": cms_name,
            "version": version,
            "findings": findings,
            "all_detected": [{"cms": d[0], "version": d[1]} for d in detected],
        }
