"""CORS misconfiguration tester.

Tests web applications for Cross-Origin Resource Sharing misconfigurations by
sending requests with various Origin headers and analyzing the CORS response headers.
"""

import asyncio
from typing import Any
from urllib.parse import urlparse

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

DEFAULT_TEST_ORIGINS = [
    "https://evil.com",
    "https://attacker.com",
    "null",
    "https://{domain}.evil.com",        # subdomain substitution
    "https://evil-{domain}",             # prefix match bypass
    "https://{domain}.attacker.com",     # subdomain of target
]

CORS_HEADERS = [
    "access-control-allow-origin",
    "access-control-allow-credentials",
    "access-control-allow-methods",
    "access-control-allow-headers",
    "access-control-expose-headers",
    "access-control-max-age",
]


class CorsTesterModule(AtsModule):
    """Test for CORS misconfiguration vulnerabilities."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="cors_tester",
            category=ModuleCategory.PENTEST,
            description="Test for CORS misconfigurations by sending crafted Origin headers and analyzing responses",
            version="1.0.0",
            parameters=[
                Parameter(name="url", type=ParameterType.URL,
                          description="Target URL to test for CORS misconfigurations", required=True),
                Parameter(name="origins_to_test", type=ParameterType.STRING,
                          description="Comma-separated list of Origin values to test",
                          default="evil.com,null,attacker.com"),
                Parameter(name="include_methods", type=ParameterType.BOOLEAN,
                          description="Also test with preflight OPTIONS requests",
                          default=True),
            ],
            outputs=[
                OutputField(name="vulnerabilities", type="list", description="Detected CORS misconfigurations"),
                OutputField(name="all_results", type="list", description="All test results with CORS headers"),
                OutputField(name="summary", type="dict", description="Test summary"),
            ],
            tags=["pentest", "cors", "web", "misconfiguration", "headers"],
            author="ATS-Toolkit",
            dangerous=False,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        url = config.get("url", "").strip()
        if not url:
            return False, "URL is required"
        if not url.startswith(("http://", "https://")):
            return False, "URL must start with http:// or https://"
        return True, ""

    def _generate_origins(self, url: str, custom_origins: str) -> list[str]:
        """Generate test Origin values including dynamic ones based on target domain."""
        parsed = urlparse(url)
        domain = parsed.hostname or ""
        scheme = parsed.scheme

        origins = []
        # Add user-specified origins
        for origin in custom_origins.split(","):
            origin = origin.strip()
            if not origin:
                continue
            if origin == "null":
                origins.append("null")
            elif not origin.startswith(("http://", "https://")):
                origins.append(f"https://{origin}")
            else:
                origins.append(origin)

        # Add dynamic origins from templates
        for template in DEFAULT_TEST_ORIGINS:
            generated = template.replace("{domain}", domain)
            if generated not in origins:
                origins.append(generated)

        # Add the target's own origin (should be allowed)
        own_origin = f"{scheme}://{domain}"
        if own_origin not in origins:
            origins.append(own_origin)

        # Add variations
        if domain:
            origins.append(f"{scheme}://{domain}.evil.com")
            origins.append(f"{scheme}://evil.{domain}")
            origins.append(f"{scheme}://{domain}%60attacker.com")

        return list(dict.fromkeys(origins))  # deduplicate preserving order

    async def _test_origin(self, session: aiohttp.ClientSession, url: str,
                            origin: str) -> dict[str, Any]:
        """Send a request with a specific Origin header and capture CORS response."""
        result: dict[str, Any] = {
            "origin_sent": origin,
            "cors_headers": {},
            "status_code": 0,
        }
        headers = {"Origin": origin}
        try:
            async with session.get(url, headers=headers, timeout=aiohttp.ClientTimeout(total=10),
                                   ssl=False, allow_redirects=True) as resp:
                result["status_code"] = resp.status
                for header in CORS_HEADERS:
                    value = resp.headers.get(header)
                    if value is not None:
                        result["cors_headers"][header] = value
        except (aiohttp.ClientError, asyncio.TimeoutError) as e:
            result["error"] = str(e)
        return result

    async def _test_preflight(self, session: aiohttp.ClientSession, url: str,
                               origin: str) -> dict[str, Any]:
        """Send a preflight OPTIONS request with Origin header."""
        result: dict[str, Any] = {
            "origin_sent": origin,
            "request_type": "preflight",
            "cors_headers": {},
            "status_code": 0,
        }
        headers = {
            "Origin": origin,
            "Access-Control-Request-Method": "POST",
            "Access-Control-Request-Headers": "X-Custom-Header, Content-Type",
        }
        try:
            async with session.options(url, headers=headers, timeout=aiohttp.ClientTimeout(total=10),
                                       ssl=False) as resp:
                result["status_code"] = resp.status
                for header in CORS_HEADERS:
                    value = resp.headers.get(header)
                    if value is not None:
                        result["cors_headers"][header] = value
        except (aiohttp.ClientError, asyncio.TimeoutError) as e:
            result["error"] = str(e)
        return result

    def _analyze_result(self, result: dict[str, Any], target_domain: str) -> dict[str, Any] | None:
        """Analyze a single CORS test result for vulnerabilities."""
        cors = result.get("cors_headers", {})
        acao = cors.get("access-control-allow-origin", "")
        acac = cors.get("access-control-allow-credentials", "").lower()
        origin_sent = result.get("origin_sent", "")

        if not acao:
            return None

        vuln = None
        # Wildcard with credentials
        if acao == "*" and acac == "true":
            vuln = {
                "type": "wildcard_with_credentials",
                "severity": "critical",
                "description": "ACAO is wildcard (*) with credentials allowed - all origins can access authenticated content",
                "origin_tested": origin_sent,
                "acao_value": acao,
                "credentials": True,
            }
        # Wildcard alone
        elif acao == "*":
            vuln = {
                "type": "wildcard_origin",
                "severity": "medium",
                "description": "ACAO is wildcard (*) - any origin can read responses",
                "origin_tested": origin_sent,
                "acao_value": acao,
                "credentials": False,
            }
        # Null origin reflected
        elif origin_sent == "null" and acao == "null":
            vuln = {
                "type": "null_origin_reflected",
                "severity": "high",
                "description": "Null origin is reflected - can be exploited via sandboxed iframes",
                "origin_tested": origin_sent,
                "acao_value": acao,
                "credentials": acac == "true",
            }
        # Arbitrary origin reflected (non-target domain)
        elif acao == origin_sent and target_domain not in origin_sent:
            severity = "critical" if acac == "true" else "high"
            vuln = {
                "type": "origin_reflected",
                "severity": severity,
                "description": f"Arbitrary origin '{origin_sent}' is reflected in ACAO"
                               + (" with credentials" if acac == "true" else ""),
                "origin_tested": origin_sent,
                "acao_value": acao,
                "credentials": acac == "true",
            }

        return vuln

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        url = config["url"].strip()
        custom_origins = config.get("origins_to_test", "evil.com,null,attacker.com")
        include_methods = config.get("include_methods", True)

        parsed = urlparse(url)
        target_domain = parsed.hostname or ""
        origins = self._generate_origins(url, custom_origins)

        self.logger.info("cors_test_start", url=url, origins_count=len(origins))

        all_results: list[dict[str, Any]] = []
        vulnerabilities: list[dict[str, Any]] = []
        connector = aiohttp.TCPConnector(limit=10, ssl=False)

        async with aiohttp.ClientSession(connector=connector) as session:
            tasks = []
            for origin in origins:
                tasks.append(self._test_origin(session, url, origin))
                if include_methods:
                    tasks.append(self._test_preflight(session, url, origin))

            results = await asyncio.gather(*tasks)
            for result in results:
                all_results.append(result)
                vuln = self._analyze_result(result, target_domain)
                if vuln:
                    # Deduplicate by type
                    existing_types = {v["type"] for v in vulnerabilities}
                    if vuln["type"] not in existing_types:
                        vulnerabilities.append(vuln)

        summary = {
            "target_url": url,
            "origins_tested": len(origins),
            "total_requests": len(all_results),
            "vulnerabilities_found": len(vulnerabilities),
            "severity_breakdown": {
                "critical": sum(1 for v in vulnerabilities if v["severity"] == "critical"),
                "high": sum(1 for v in vulnerabilities if v["severity"] == "high"),
                "medium": sum(1 for v in vulnerabilities if v["severity"] == "medium"),
            },
        }

        self.logger.info("cors_test_complete", vulns=len(vulnerabilities))
        return {"vulnerabilities": vulnerabilities, "all_results": all_results, "summary": summary}
