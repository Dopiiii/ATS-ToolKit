"""Cross-Site Request Forgery (CSRF) vulnerability tester.

Analyzes HTML forms for CSRF protection, checks for anti-CSRF tokens,
validates token implementation, and tests for common CSRF bypasses.
"""

import asyncio
import re
from typing import Any
from urllib.parse import urlparse, urljoin

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

# Known CSRF token field names (case-insensitive matching)
CSRF_TOKEN_NAMES = [
    "csrf", "csrf_token", "csrftoken", "csrfmiddlewaretoken",
    "_csrf", "_csrf_token", "xsrf", "xsrf_token", "_xsrf",
    "anti-csrf", "anti_csrf_token", "authenticity_token",
    "__requestverificationtoken", "token", "form_token",
    "nonce", "_wpnonce", "form_key", "form_build_id",
    "viewstate", "__viewstate", "__eventvalidation",
    "antiforgery", "__antiforgery", "verify", "verification_token",
]

# CSRF-related HTTP headers
CSRF_HEADERS = [
    "x-csrf-token", "x-xsrf-token", "x-csrftoken",
    "x-requested-with", "x-anti-csrf-token",
]

# SameSite cookie attribute values that mitigate CSRF
SAMESITE_SAFE_VALUES = ["strict", "lax"]


class CsrfTesterModule(AtsModule):
    """Test web applications for Cross-Site Request Forgery vulnerabilities."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="csrf_tester",
            category=ModuleCategory.PENTEST,
            description="Test for CSRF vulnerabilities by analyzing HTML forms, anti-CSRF tokens, cookie attributes, and common bypass techniques",
            version="1.0.0",
            parameters=[
                Parameter(name="url", type=ParameterType.URL,
                          description="Target URL containing forms to analyze", required=True),
                Parameter(name="crawl_depth", type=ParameterType.INTEGER,
                          description="Depth of link crawling to discover forms (0 = target page only)",
                          default=1, min_value=0, max_value=3),
                Parameter(name="test_bypasses", type=ParameterType.BOOLEAN,
                          description="Attempt common CSRF bypass techniques",
                          default=True),
                Parameter(name="cookies", type=ParameterType.STRING,
                          description="Session cookies to include (format: name=value; name2=value2)",
                          required=False, default=""),
            ],
            outputs=[
                OutputField(name="vulnerabilities", type="list",
                            description="Detected CSRF vulnerabilities and weak protections"),
                OutputField(name="forms_analyzed", type="list",
                            description="Details of all HTML forms found and analyzed"),
                OutputField(name="summary", type="dict",
                            description="Scan summary with statistics"),
            ],
            requires_api_key=False,
            api_key_service=None,
            tags=["pentest", "csrf", "web", "forms", "tokens"],
            author="ATS-Toolkit",
            dangerous=True,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        url = config.get("url", "").strip()
        if not url:
            return False, "URL is required"
        if not url.startswith(("http://", "https://")):
            return False, "URL must start with http:// or https://"
        return True, ""

    def _parse_cookies(self, cookie_str: str) -> dict[str, str]:
        """Parse cookie string into a dictionary."""
        cookies: dict[str, str] = {}
        if not cookie_str:
            return cookies
        for pair in cookie_str.split(";"):
            pair = pair.strip()
            if "=" in pair:
                name, value = pair.split("=", 1)
                cookies[name.strip()] = value.strip()
        return cookies

    def _extract_forms(self, html: str, base_url: str) -> list[dict[str, Any]]:
        """Extract all HTML forms with their inputs from page source."""
        forms = []
        form_pattern = re.compile(
            r'<form\b([^>]*)>(.*?)</form>',
            re.IGNORECASE | re.DOTALL,
        )

        for match in form_pattern.finditer(html):
            attrs_str = match.group(1)
            body = match.group(2)

            form: dict[str, Any] = {
                "action": self._extract_attr(attrs_str, "action", ""),
                "method": self._extract_attr(attrs_str, "method", "GET").upper(),
                "enctype": self._extract_attr(attrs_str, "enctype", ""),
                "id": self._extract_attr(attrs_str, "id", ""),
                "name": self._extract_attr(attrs_str, "name", ""),
                "inputs": [],
                "has_csrf_token": False,
                "csrf_token_field": None,
            }

            # Resolve relative action URLs
            if form["action"] and not form["action"].startswith(("http://", "https://")):
                form["action"] = urljoin(base_url, form["action"])
            elif not form["action"]:
                form["action"] = base_url

            # Extract all input/select/textarea fields
            input_pattern = re.compile(
                r'<(?:input|select|textarea)\b([^>]*)/?>', re.IGNORECASE
            )
            for inp_match in input_pattern.finditer(body):
                inp_attrs = inp_match.group(1)
                inp = {
                    "name": self._extract_attr(inp_attrs, "name", ""),
                    "type": self._extract_attr(inp_attrs, "type", "text").lower(),
                    "value": self._extract_attr(inp_attrs, "value", ""),
                    "id": self._extract_attr(inp_attrs, "id", ""),
                }
                form["inputs"].append(inp)

                # Check if this input is a CSRF token
                if inp["name"] and self._is_csrf_field(inp["name"], inp["type"]):
                    form["has_csrf_token"] = True
                    form["csrf_token_field"] = inp["name"]

            forms.append(form)

        return forms

    def _extract_attr(self, attrs_str: str, attr_name: str, default: str) -> str:
        """Extract an attribute value from an HTML tag's attribute string."""
        pattern = re.compile(
            rf'{attr_name}\s*=\s*["\']([^"\']*)["\']', re.IGNORECASE
        )
        match = pattern.search(attrs_str)
        if match:
            return match.group(1)
        # Try unquoted
        pattern_unquoted = re.compile(
            rf'{attr_name}\s*=\s*(\S+)', re.IGNORECASE
        )
        match_unq = pattern_unquoted.search(attrs_str)
        if match_unq:
            return match_unq.group(1)
        return default

    def _is_csrf_field(self, field_name: str, field_type: str) -> bool:
        """Check if a form field looks like a CSRF token."""
        name_lower = field_name.lower().replace("-", "_")
        if field_type == "hidden":
            for token_name in CSRF_TOKEN_NAMES:
                if token_name in name_lower or name_lower in token_name:
                    return True
        # Also check non-hidden fields with CSRF-like names
        for token_name in CSRF_TOKEN_NAMES:
            if name_lower == token_name:
                return True
        return False

    def _analyze_csrf_token(self, token_value: str) -> dict[str, Any]:
        """Analyze the quality of a CSRF token value."""
        analysis: dict[str, Any] = {
            "length": len(token_value),
            "appears_random": False,
            "issues": [],
        }

        if not token_value:
            analysis["issues"].append("Token field exists but value is empty")
            return analysis

        if len(token_value) < 16:
            analysis["issues"].append(f"Token is too short ({len(token_value)} chars) - should be >= 32")

        # Check entropy: count unique characters
        unique_ratio = len(set(token_value)) / len(token_value) if token_value else 0
        if unique_ratio < 0.3:
            analysis["issues"].append("Token has low entropy - may be predictable")

        # Check if token is purely numeric (weak)
        if token_value.isdigit():
            analysis["issues"].append("Token is purely numeric - likely weak or sequential")

        # Check for timestamp-like patterns
        if re.match(r'^\d{10,13}$', token_value):
            analysis["issues"].append("Token looks like a Unix timestamp - predictable")

        if not analysis["issues"] and len(token_value) >= 16 and unique_ratio >= 0.3:
            analysis["appears_random"] = True

        return analysis

    def _analyze_cookies(self, set_cookie_headers: list[str]) -> dict[str, Any]:
        """Analyze Set-Cookie headers for CSRF-relevant attributes."""
        cookie_analysis: dict[str, Any] = {
            "cookies_found": len(set_cookie_headers),
            "samesite_status": [],
            "issues": [],
        }

        for header in set_cookie_headers:
            cookie_name = header.split("=", 1)[0].strip() if "=" in header else "unknown"
            header_lower = header.lower()

            samesite_match = re.search(r'samesite\s*=\s*(\w+)', header_lower)
            if samesite_match:
                ss_value = samesite_match.group(1)
                cookie_analysis["samesite_status"].append({
                    "cookie": cookie_name,
                    "samesite": ss_value,
                    "safe": ss_value in SAMESITE_SAFE_VALUES,
                })
                if ss_value == "none":
                    cookie_analysis["issues"].append(
                        f"Cookie '{cookie_name}' has SameSite=None - does not prevent CSRF"
                    )
            else:
                cookie_analysis["samesite_status"].append({
                    "cookie": cookie_name,
                    "samesite": "not_set",
                    "safe": False,
                })
                cookie_analysis["issues"].append(
                    f"Cookie '{cookie_name}' has no SameSite attribute"
                )

        return cookie_analysis

    async def _fetch_page(self, session: aiohttp.ClientSession, url: str,
                           timeout: int) -> tuple[str, list[str], dict[str, str], int]:
        """Fetch a page and return (body, set_cookie_headers, response_headers, status)."""
        try:
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=timeout),
                                   ssl=False, allow_redirects=True) as resp:
                body = await resp.text(errors="replace")
                set_cookies = resp.headers.getall("Set-Cookie", [])
                headers = {k.lower(): v for k, v in resp.headers.items()}
                return body, list(set_cookies), headers, resp.status
        except (aiohttp.ClientError, asyncio.TimeoutError):
            return "", [], {}, 0

    def _extract_links(self, html: str, base_url: str) -> list[str]:
        """Extract same-origin links from HTML for crawling."""
        parsed_base = urlparse(base_url)
        links: list[str] = []
        seen: set[str] = set()

        for match in re.finditer(r'href\s*=\s*["\']([^"\'#]+)["\']', html, re.IGNORECASE):
            href = match.group(1)
            full_url = urljoin(base_url, href)
            parsed = urlparse(full_url)

            # Same origin only
            if parsed.hostname == parsed_base.hostname and full_url not in seen:
                # Skip non-HTML resources
                if not re.search(r'\.(css|js|png|jpg|gif|svg|ico|woff|pdf|zip)$',
                                 parsed.path, re.IGNORECASE):
                    links.append(full_url)
                    seen.add(full_url)

        return links[:50]  # limit to 50 links

    async def _test_token_reuse(self, session: aiohttp.ClientSession, url: str,
                                 timeout: int) -> dict[str, Any]:
        """Check if CSRF tokens change between requests (token reuse detection)."""
        tokens_seen: list[str] = []

        for _ in range(3):
            body, _, _, status = await self._fetch_page(session, url, timeout)
            if status == 0:
                break
            forms = self._extract_forms(body, url)
            for form in forms:
                if form["has_csrf_token"]:
                    for inp in form["inputs"]:
                        if inp["name"] == form["csrf_token_field"] and inp["value"]:
                            tokens_seen.append(inp["value"])
            await asyncio.sleep(0.5)

        result: dict[str, Any] = {"tokens_collected": len(tokens_seen), "reuse_detected": False}
        if len(tokens_seen) >= 2:
            unique = set(tokens_seen)
            if len(unique) == 1:
                result["reuse_detected"] = True
                result["issue"] = "CSRF token does not change between requests - static token"

        return result

    async def _test_method_override(self, session: aiohttp.ClientSession,
                                     form: dict[str, Any],
                                     timeout: int) -> dict[str, Any]:
        """Test if POST forms accept GET requests (method override bypass)."""
        result: dict[str, Any] = {"bypass_possible": False}
        if form["method"] != "POST":
            return result

        action = form["action"]
        try:
            async with session.get(action, timeout=aiohttp.ClientTimeout(total=timeout),
                                   ssl=False, allow_redirects=True) as resp:
                if resp.status < 400:
                    result["bypass_possible"] = True
                    result["detail"] = f"POST form at {action} also accepts GET (status {resp.status})"
        except (aiohttp.ClientError, asyncio.TimeoutError):
            pass

        return result

    async def _test_empty_token(self, session: aiohttp.ClientSession,
                                 form: dict[str, Any],
                                 timeout: int) -> dict[str, Any]:
        """Test if the form accepts an empty CSRF token value."""
        result: dict[str, Any] = {"bypass_possible": False}
        if not form["has_csrf_token"] or form["method"] != "POST":
            return result

        action = form["action"]
        data: dict[str, str] = {}
        for inp in form["inputs"]:
            if inp["name"]:
                if inp["name"] == form["csrf_token_field"]:
                    data[inp["name"]] = ""  # empty token
                else:
                    data[inp["name"]] = inp["value"] or "test"

        try:
            async with session.post(action, data=data,
                                    timeout=aiohttp.ClientTimeout(total=timeout),
                                    ssl=False, allow_redirects=True) as resp:
                if resp.status < 400:
                    result["bypass_possible"] = True
                    result["detail"] = f"Form at {action} accepted empty CSRF token (status {resp.status})"
        except (aiohttp.ClientError, asyncio.TimeoutError):
            pass

        return result

    async def _test_removed_token(self, session: aiohttp.ClientSession,
                                   form: dict[str, Any],
                                   timeout: int) -> dict[str, Any]:
        """Test if the form processes the request when the CSRF token parameter is removed."""
        result: dict[str, Any] = {"bypass_possible": False}
        if not form["has_csrf_token"] or form["method"] != "POST":
            return result

        action = form["action"]
        data: dict[str, str] = {}
        for inp in form["inputs"]:
            if inp["name"] and inp["name"] != form["csrf_token_field"]:
                data[inp["name"]] = inp["value"] or "test"

        try:
            async with session.post(action, data=data,
                                    timeout=aiohttp.ClientTimeout(total=timeout),
                                    ssl=False, allow_redirects=True) as resp:
                if resp.status < 400:
                    result["bypass_possible"] = True
                    result["detail"] = f"Form at {action} processed request without CSRF token (status {resp.status})"
        except (aiohttp.ClientError, asyncio.TimeoutError):
            pass

        return result

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        url = config["url"].strip()
        crawl_depth = config.get("crawl_depth", 1)
        test_bypasses = config.get("test_bypasses", True)
        cookie_str = config.get("cookies", "")
        timeout = 10

        cookies = self._parse_cookies(cookie_str)

        self.logger.info("csrf_test_start", url=url, crawl_depth=crawl_depth)

        connector = aiohttp.TCPConnector(limit=10, ssl=False)
        jar = aiohttp.CookieJar(unsafe=True)
        for name, value in cookies.items():
            jar.update_cookies({name: value})

        all_vulns: list[dict[str, Any]] = []
        all_forms_analyzed: list[dict[str, Any]] = []
        pages_visited: set[str] = set()
        pages_to_visit: list[tuple[str, int]] = [(url, 0)]

        async with aiohttp.ClientSession(connector=connector, cookie_jar=jar) as session:
            while pages_to_visit:
                current_url, depth = pages_to_visit.pop(0)
                if current_url in pages_visited:
                    continue
                pages_visited.add(current_url)

                body, set_cookies, resp_headers, status = await self._fetch_page(
                    session, current_url, timeout
                )
                if status == 0:
                    continue

                # Analyze cookies from this page
                cookie_analysis = self._analyze_cookies(set_cookies)
                if cookie_analysis["issues"]:
                    for issue in cookie_analysis["issues"]:
                        all_vulns.append({
                            "type": "cookie_issue",
                            "url": current_url,
                            "severity": "medium",
                            "description": issue,
                        })

                # Check for CSRF-related response headers
                has_csrf_header = False
                for h in CSRF_HEADERS:
                    if h in resp_headers:
                        has_csrf_header = True
                        break

                # Extract and analyze forms
                forms = self._extract_forms(body, current_url)
                for form in forms:
                    form_info: dict[str, Any] = {
                        "page_url": current_url,
                        "action": form["action"],
                        "method": form["method"],
                        "has_csrf_token": form["has_csrf_token"],
                        "csrf_token_field": form["csrf_token_field"],
                        "input_count": len(form["inputs"]),
                        "vulnerabilities": [],
                    }

                    # State-changing forms without CSRF protection
                    if form["method"] == "POST" and not form["has_csrf_token"] and not has_csrf_header:
                        vuln = {
                            "type": "missing_csrf_token",
                            "url": current_url,
                            "form_action": form["action"],
                            "severity": "high",
                            "description": f"POST form at {current_url} (action: {form['action']}) has no CSRF token",
                        }
                        all_vulns.append(vuln)
                        form_info["vulnerabilities"].append(vuln)

                    # Analyze token quality if present
                    if form["has_csrf_token"]:
                        for inp in form["inputs"]:
                            if inp["name"] == form["csrf_token_field"]:
                                token_analysis = self._analyze_csrf_token(inp["value"])
                                form_info["token_analysis"] = token_analysis
                                if token_analysis["issues"]:
                                    vuln = {
                                        "type": "weak_csrf_token",
                                        "url": current_url,
                                        "form_action": form["action"],
                                        "token_field": inp["name"],
                                        "severity": "medium",
                                        "issues": token_analysis["issues"],
                                        "description": f"CSRF token quality issues: {'; '.join(token_analysis['issues'])}",
                                    }
                                    all_vulns.append(vuln)
                                    form_info["vulnerabilities"].append(vuln)
                                break

                    # Bypass tests
                    if test_bypasses and form["method"] == "POST":
                        method_result = await self._test_method_override(session, form, timeout)
                        if method_result.get("bypass_possible"):
                            vuln = {
                                "type": "method_override_bypass",
                                "url": current_url,
                                "form_action": form["action"],
                                "severity": "medium",
                                "description": method_result["detail"],
                            }
                            all_vulns.append(vuln)
                            form_info["vulnerabilities"].append(vuln)

                        if form["has_csrf_token"]:
                            empty_result = await self._test_empty_token(session, form, timeout)
                            if empty_result.get("bypass_possible"):
                                vuln = {
                                    "type": "empty_token_bypass",
                                    "url": current_url,
                                    "form_action": form["action"],
                                    "severity": "high",
                                    "description": empty_result["detail"],
                                }
                                all_vulns.append(vuln)
                                form_info["vulnerabilities"].append(vuln)

                            removed_result = await self._test_removed_token(session, form, timeout)
                            if removed_result.get("bypass_possible"):
                                vuln = {
                                    "type": "token_removal_bypass",
                                    "url": current_url,
                                    "form_action": form["action"],
                                    "severity": "high",
                                    "description": removed_result["detail"],
                                }
                                all_vulns.append(vuln)
                                form_info["vulnerabilities"].append(vuln)

                    all_forms_analyzed.append(form_info)

                # Token reuse test (once per page with CSRF forms)
                if test_bypasses and any(f["has_csrf_token"] for f in forms):
                    reuse = await self._test_token_reuse(session, current_url, timeout)
                    if reuse.get("reuse_detected"):
                        all_vulns.append({
                            "type": "static_csrf_token",
                            "url": current_url,
                            "severity": "medium",
                            "description": reuse["issue"],
                        })

                # Crawl for more pages
                if depth < crawl_depth:
                    links = self._extract_links(body, current_url)
                    for link in links:
                        if link not in pages_visited:
                            pages_to_visit.append((link, depth + 1))

        summary = {
            "target_url": url,
            "pages_analyzed": len(pages_visited),
            "forms_found": len(all_forms_analyzed),
            "forms_without_csrf": sum(
                1 for f in all_forms_analyzed
                if not f["has_csrf_token"] and f.get("method") == "POST"
            ),
            "vulnerabilities_found": len(all_vulns),
            "severity_breakdown": {
                "critical": sum(1 for v in all_vulns if v.get("severity") == "critical"),
                "high": sum(1 for v in all_vulns if v.get("severity") == "high"),
                "medium": sum(1 for v in all_vulns if v.get("severity") == "medium"),
                "low": sum(1 for v in all_vulns if v.get("severity") == "low"),
            },
        }

        self.logger.info("csrf_test_complete", vulns=len(all_vulns),
                         forms=len(all_forms_analyzed))
        return {
            "vulnerabilities": all_vulns,
            "forms_analyzed": all_forms_analyzed,
            "summary": summary,
        }
