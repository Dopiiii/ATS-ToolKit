"""HTTP security headers analyzer.

Evaluates the security posture of HTTP response headers, checking for the
presence and proper configuration of security-related headers.
"""

import asyncio
from typing import Any

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

SECURITY_HEADERS: dict[str, dict[str, Any]] = {
    "Strict-Transport-Security": {
        "weight": 15,
        "description": "HTTP Strict Transport Security forces HTTPS connections",
        "recommendation": "Add 'Strict-Transport-Security: max-age=31536000; includeSubDomains; preload'",
        "good_patterns": ["max-age="],
        "bad_patterns": ["max-age=0"],
    },
    "Content-Security-Policy": {
        "weight": 20,
        "description": "Content Security Policy prevents XSS, clickjacking, and code injection",
        "recommendation": "Add 'Content-Security-Policy: default-src \\'self\\'; script-src \\'self\\'",
        "good_patterns": ["default-src", "script-src"],
        "bad_patterns": ["unsafe-inline", "unsafe-eval", "*"],
    },
    "X-Frame-Options": {
        "weight": 10,
        "description": "Prevents clickjacking by controlling iframe embedding",
        "recommendation": "Add 'X-Frame-Options: DENY' or 'X-Frame-Options: SAMEORIGIN'",
        "good_patterns": ["DENY", "SAMEORIGIN"],
        "bad_patterns": ["ALLOW-FROM"],
    },
    "X-Content-Type-Options": {
        "weight": 10,
        "description": "Prevents MIME type sniffing",
        "recommendation": "Add 'X-Content-Type-Options: nosniff'",
        "good_patterns": ["nosniff"],
        "bad_patterns": [],
    },
    "X-XSS-Protection": {
        "weight": 5,
        "description": "Legacy XSS filter (deprecated but still useful for older browsers)",
        "recommendation": "Add 'X-XSS-Protection: 1; mode=block' or consider removing in favor of CSP",
        "good_patterns": ["1; mode=block"],
        "bad_patterns": ["0"],
    },
    "Referrer-Policy": {
        "weight": 10,
        "description": "Controls how much referrer information is shared",
        "recommendation": "Add 'Referrer-Policy: strict-origin-when-cross-origin' or 'no-referrer'",
        "good_patterns": ["no-referrer", "strict-origin", "same-origin"],
        "bad_patterns": ["unsafe-url"],
    },
    "Permissions-Policy": {
        "weight": 10,
        "description": "Controls browser feature access (camera, microphone, geolocation, etc.)",
        "recommendation": "Add 'Permissions-Policy: camera=(), microphone=(), geolocation=()'",
        "good_patterns": ["camera=", "microphone=", "geolocation="],
        "bad_patterns": [],
    },
    "X-Permitted-Cross-Domain-Policies": {
        "weight": 5,
        "description": "Controls cross-domain policy files for Flash and PDF",
        "recommendation": "Add 'X-Permitted-Cross-Domain-Policies: none'",
        "good_patterns": ["none", "master-only"],
        "bad_patterns": ["all"],
    },
    "Cross-Origin-Embedder-Policy": {
        "weight": 5,
        "description": "Controls embedding of cross-origin resources",
        "recommendation": "Add 'Cross-Origin-Embedder-Policy: require-corp'",
        "good_patterns": ["require-corp"],
        "bad_patterns": [],
    },
    "Cross-Origin-Resource-Policy": {
        "weight": 5,
        "description": "Controls who can read cross-origin resources",
        "recommendation": "Add 'Cross-Origin-Resource-Policy: same-origin'",
        "good_patterns": ["same-origin", "same-site"],
        "bad_patterns": ["cross-origin"],
    },
    "Cross-Origin-Opener-Policy": {
        "weight": 5,
        "description": "Controls window interaction between origins",
        "recommendation": "Add 'Cross-Origin-Opener-Policy: same-origin'",
        "good_patterns": ["same-origin"],
        "bad_patterns": [],
    },
}

INFORMATION_DISCLOSURE_HEADERS = [
    "Server", "X-Powered-By", "X-AspNet-Version", "X-AspNetMvc-Version",
    "X-Generator", "X-Drupal-Cache", "X-Varnish",
]


class HeaderSecurityModule(AtsModule):
    """Analyze HTTP security headers and provide a security score."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="header_security",
            category=ModuleCategory.PENTEST,
            description="Analyze HTTP response security headers, score configuration, and provide recommendations",
            version="1.0.0",
            parameters=[
                Parameter(name="url", type=ParameterType.URL,
                          description="Target URL to analyze security headers", required=True),
                Parameter(name="include_recommendations", type=ParameterType.BOOLEAN,
                          description="Include remediation recommendations in output",
                          default=True),
                Parameter(name="check_info_disclosure", type=ParameterType.BOOLEAN,
                          description="Also check for information disclosure headers",
                          default=True),
            ],
            outputs=[
                OutputField(name="found", type="list", description="Present security headers with analysis"),
                OutputField(name="missing", type="list", description="Missing security headers"),
                OutputField(name="score", type="integer", description="Security score 0-100"),
                OutputField(name="recommendations", type="list", description="Remediation recommendations"),
            ],
            tags=["pentest", "headers", "web", "security", "hardening"],
            author="ATS-Toolkit",
            dangerous=False,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        url = config.get("url", "").strip()
        if not url:
            return False, "URL is required"
        if not url.startswith(("http://", "https://")):
            return False, "URL must start with http:// or https://"
        return True, ""

    async def _fetch_headers(self, url: str) -> tuple[dict[str, str], int]:
        """Fetch response headers from the target URL."""
        connector = aiohttp.TCPConnector(ssl=False)
        async with aiohttp.ClientSession(connector=connector) as session:
            try:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=15),
                                       ssl=False, allow_redirects=True) as resp:
                    headers = {k: v for k, v in resp.headers.items()}
                    return headers, resp.status
            except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                return {}, 0

    def _analyze_header(self, name: str, value: str,
                         spec: dict[str, Any]) -> dict[str, Any]:
        """Analyze a single security header value."""
        analysis: dict[str, Any] = {
            "header": name,
            "value": value,
            "status": "present",
            "issues": [],
        }

        # Check for bad patterns
        for bad in spec.get("bad_patterns", []):
            if bad.lower() in value.lower():
                analysis["issues"].append(f"Contains potentially insecure value: '{bad}'")
                analysis["status"] = "weak"

        # Check for good patterns
        has_good = False
        for good in spec.get("good_patterns", []):
            if good.lower() in value.lower():
                has_good = True
                break
        if not has_good and spec.get("good_patterns"):
            analysis["issues"].append("Missing recommended directives")
            if analysis["status"] == "present":
                analysis["status"] = "partial"

        if not analysis["issues"]:
            analysis["status"] = "good"
        return analysis

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        url = config["url"].strip()
        include_recommendations = config.get("include_recommendations", True)
        check_info_disclosure = config.get("check_info_disclosure", True)

        self.logger.info("header_scan_start", url=url)
        headers, status_code = await self._fetch_headers(url)

        if status_code == 0:
            return {
                "found": [], "missing": [], "score": 0, "recommendations": [],
                "error": "Could not connect to target",
            }

        # Normalize headers for case-insensitive lookup
        headers_lower = {k.lower(): (k, v) for k, v in headers.items()}

        found: list[dict[str, Any]] = []
        missing: list[dict[str, Any]] = []
        recommendations: list[dict[str, Any]] = []
        total_weight = sum(s["weight"] for s in SECURITY_HEADERS.values())
        earned_weight = 0

        for header_name, spec in SECURITY_HEADERS.items():
            key = header_name.lower()
            if key in headers_lower:
                original_name, value = headers_lower[key]
                analysis = self._analyze_header(header_name, value, spec)
                found.append(analysis)
                if analysis["status"] == "good":
                    earned_weight += spec["weight"]
                elif analysis["status"] == "partial":
                    earned_weight += spec["weight"] * 0.5
                elif analysis["status"] == "weak":
                    earned_weight += spec["weight"] * 0.25
                    if include_recommendations:
                        recommendations.append({
                            "header": header_name,
                            "priority": "high",
                            "issue": f"Header present but misconfigured: {', '.join(analysis['issues'])}",
                            "fix": spec["recommendation"],
                        })
            else:
                missing.append({
                    "header": header_name,
                    "description": spec["description"],
                    "weight": spec["weight"],
                })
                if include_recommendations:
                    recommendations.append({
                        "header": header_name,
                        "priority": "medium" if spec["weight"] >= 10 else "low",
                        "issue": f"Missing security header: {header_name}",
                        "fix": spec["recommendation"],
                    })

        # Information disclosure check
        info_disclosure: list[dict[str, str]] = []
        if check_info_disclosure:
            for hdr in INFORMATION_DISCLOSURE_HEADERS:
                key = hdr.lower()
                if key in headers_lower:
                    original_name, value = headers_lower[key]
                    info_disclosure.append({"header": original_name, "value": value})
                    if include_recommendations:
                        recommendations.append({
                            "header": original_name,
                            "priority": "low",
                            "issue": f"Information disclosure via {original_name}: {value}",
                            "fix": f"Remove or suppress the '{original_name}' header",
                        })

        score = int((earned_weight / total_weight) * 100) if total_weight > 0 else 0

        # Sort recommendations by priority
        priority_order = {"high": 0, "medium": 1, "low": 2}
        recommendations.sort(key=lambda r: priority_order.get(r.get("priority", "low"), 3))

        summary = {
            "url": url,
            "status_code": status_code,
            "headers_found": len(found),
            "headers_missing": len(missing),
            "score": score,
            "grade": "A" if score >= 90 else "B" if score >= 70 else "C" if score >= 50 else "D" if score >= 30 else "F",
        }

        self.logger.info("header_scan_complete", score=score, found=len(found), missing=len(missing))
        return {
            "found": found,
            "missing": missing,
            "score": score,
            "recommendations": recommendations,
            "info_disclosure": info_disclosure,
            "summary": summary,
        }
