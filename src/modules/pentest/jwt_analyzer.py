"""JWT token analyzer.

Decodes and analyzes JSON Web Tokens for security weaknesses including
insecure algorithms, missing claims, and known vulnerabilities.
"""

import asyncio
import base64
import json
import hashlib
import hmac
import time
from typing import Any

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

WEAK_SECRETS = [
    "secret", "password", "123456", "admin", "key", "jwt_secret",
    "changeme", "test", "default", "mysecret", "supersecret",
    "passw0rd", "qwerty", "jwt", "token", "secret123",
    "password123", "letmein", "welcome", "monkey",
]


class JwtAnalyzerModule(AtsModule):
    """Decode and analyze JWT tokens for security vulnerabilities."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="jwt_analyzer",
            category=ModuleCategory.PENTEST,
            description="Decode JWT tokens and check for algorithm confusion, weak secrets, and insecure claims",
            version="1.0.0",
            parameters=[
                Parameter(name="token", type=ParameterType.STRING,
                          description="JWT token to analyze", required=True),
                Parameter(name="check_signature", type=ParameterType.BOOLEAN,
                          description="Attempt to verify signature with common weak secrets",
                          default=True),
                Parameter(name="check_expiry", type=ParameterType.BOOLEAN,
                          description="Check token expiration and time-based claims",
                          default=True),
            ],
            outputs=[
                OutputField(name="decoded_header", type="dict", description="Decoded JWT header"),
                OutputField(name="decoded_payload", type="dict", description="Decoded JWT payload"),
                OutputField(name="vulnerabilities", type="list", description="Security issues found"),
            ],
            tags=["pentest", "jwt", "authentication", "token", "web"],
            author="ATS-Toolkit",
            dangerous=False,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        token = config.get("token", "").strip()
        if not token:
            return False, "JWT token is required"
        parts = token.split(".")
        if len(parts) not in (2, 3):
            return False, "Invalid JWT format: expected 2 or 3 dot-separated parts"
        return True, ""

    def _b64_decode(self, data: str) -> bytes:
        """Decode base64url-encoded data with padding correction."""
        padding = 4 - len(data) % 4
        if padding != 4:
            data += "=" * padding
        return base64.urlsafe_b64decode(data)

    def _b64_encode(self, data: bytes) -> str:
        """Encode data as base64url without padding."""
        return base64.urlsafe_b64encode(data).rstrip(b"=").decode("ascii")

    def _decode_part(self, part: str) -> dict[str, Any]:
        """Decode a JWT header or payload part."""
        try:
            decoded_bytes = self._b64_decode(part)
            return json.loads(decoded_bytes.decode("utf-8"))
        except (json.JSONDecodeError, ValueError, UnicodeDecodeError):
            return {"_raw": part, "_error": "Failed to decode"}

    def _check_algorithm(self, header: dict[str, Any]) -> list[dict[str, Any]]:
        """Check for algorithm-related vulnerabilities."""
        vulns = []
        alg = header.get("alg", "").upper()

        if alg == "NONE" or alg == "":
            vulns.append({
                "type": "algorithm_none",
                "severity": "critical",
                "description": "Algorithm is 'none' - token has no signature verification",
                "recommendation": "Enforce a strong algorithm (RS256, ES256) on the server",
            })
        elif alg in ("HS256", "HS384", "HS512"):
            vulns.append({
                "type": "symmetric_algorithm",
                "severity": "medium",
                "description": f"Token uses symmetric algorithm ({alg}) - shared secret may be brute-forced",
                "recommendation": "Consider using asymmetric algorithms (RS256, ES256) for better security",
            })
        elif alg in ("RS256", "RS384", "RS512"):
            # Check for potential algorithm confusion (RSA -> HMAC)
            vulns.append({
                "type": "algorithm_confusion_risk",
                "severity": "info",
                "description": f"Token uses {alg} - ensure server does not accept HS256 with the public key",
                "recommendation": "Verify server strictly validates the algorithm in the header",
            })

        if "kid" not in header and alg not in ("NONE", ""):
            vulns.append({
                "type": "missing_kid",
                "severity": "low",
                "description": "No 'kid' (Key ID) claim in header - may allow key confusion",
                "recommendation": "Include 'kid' header to explicitly identify the signing key",
            })

        if "jku" in header:
            vulns.append({
                "type": "jku_present",
                "severity": "high",
                "description": f"JKU header points to: {header['jku']} - may allow key injection",
                "recommendation": "Validate JKU URL against a strict whitelist on the server",
            })

        if "x5u" in header:
            vulns.append({
                "type": "x5u_present",
                "severity": "high",
                "description": "X5U header present - may allow certificate injection",
                "recommendation": "Validate X5U URL against a strict whitelist on the server",
            })

        return vulns

    def _check_claims(self, payload: dict[str, Any], check_expiry: bool) -> list[dict[str, Any]]:
        """Check for issues with JWT claims."""
        vulns = []
        now = int(time.time())

        if check_expiry:
            exp = payload.get("exp")
            if exp is None:
                vulns.append({
                    "type": "no_expiry",
                    "severity": "high",
                    "description": "Token has no expiration (exp) claim - never expires",
                    "recommendation": "Always include 'exp' claim with a reasonable expiry time",
                })
            elif isinstance(exp, (int, float)):
                if exp < now:
                    vulns.append({
                        "type": "expired_token",
                        "severity": "info",
                        "description": f"Token expired at {exp} (current time: {now})",
                        "recommendation": "Token should be refreshed",
                    })
                elif exp - now > 86400 * 365:
                    vulns.append({
                        "type": "long_expiry",
                        "severity": "medium",
                        "description": f"Token has very long expiry (>{(exp - now) // 86400} days)",
                        "recommendation": "Use shorter token lifetimes and implement refresh tokens",
                    })

            nbf = payload.get("nbf")
            if isinstance(nbf, (int, float)) and nbf > now:
                vulns.append({
                    "type": "not_yet_valid",
                    "severity": "info",
                    "description": f"Token is not yet valid (nbf: {nbf}, current: {now})",
                    "recommendation": "Check system clock synchronization",
                })

            iat = payload.get("iat")
            if iat is None:
                vulns.append({
                    "type": "no_issued_at",
                    "severity": "low",
                    "description": "No 'iat' (Issued At) claim - cannot determine token age",
                    "recommendation": "Include 'iat' claim for token age verification",
                })

        if "sub" not in payload and "user" not in payload and "email" not in payload:
            vulns.append({
                "type": "no_subject",
                "severity": "low",
                "description": "No 'sub' claim - token does not identify a subject",
                "recommendation": "Include 'sub' claim to identify the token subject",
            })

        if "iss" not in payload:
            vulns.append({
                "type": "no_issuer",
                "severity": "medium",
                "description": "No 'iss' (Issuer) claim - cannot verify token origin",
                "recommendation": "Include 'iss' claim and validate it on the server",
            })

        # Check for sensitive data in payload
        sensitive_keys = ["password", "secret", "ssn", "credit_card", "cc_number",
                          "private_key", "api_key", "access_key"]
        for key in payload:
            if key.lower() in sensitive_keys:
                vulns.append({
                    "type": "sensitive_data_in_token",
                    "severity": "high",
                    "description": f"Potentially sensitive field '{key}' found in JWT payload",
                    "recommendation": "Never store sensitive data in JWT tokens (they are not encrypted)",
                })

        return vulns

    def _try_weak_secrets(self, token: str, header: dict[str, Any]) -> list[dict[str, Any]]:
        """Attempt to verify the signature with common weak secrets."""
        vulns = []
        alg = header.get("alg", "").upper()

        if alg not in ("HS256", "HS384", "HS512"):
            return vulns

        parts = token.split(".")
        if len(parts) != 3:
            return vulns

        signing_input = f"{parts[0]}.{parts[1]}".encode("ascii")
        signature = self._b64_decode(parts[2])

        hash_alg = {"HS256": "sha256", "HS384": "sha384", "HS512": "sha512"}.get(alg, "sha256")

        for secret in WEAK_SECRETS:
            expected = hmac.new(secret.encode("utf-8"), signing_input, hash_alg).digest()
            if hmac.compare_digest(expected, signature):
                vulns.append({
                    "type": "weak_secret",
                    "severity": "critical",
                    "description": f"JWT signature verified with weak secret: '{secret}'",
                    "recommendation": "Use a strong, random secret (256+ bits) for HMAC signing",
                    "cracked_secret": secret,
                })
                break
        return vulns

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        token = config["token"].strip()
        check_signature = config.get("check_signature", True)
        check_expiry = config.get("check_expiry", True)

        self.logger.info("jwt_analysis_start")

        parts = token.split(".")
        header = self._decode_part(parts[0])
        payload = self._decode_part(parts[1])
        has_signature = len(parts) == 3 and len(parts[2]) > 0

        vulnerabilities: list[dict[str, Any]] = []
        vulnerabilities.extend(self._check_algorithm(header))
        vulnerabilities.extend(self._check_claims(payload, check_expiry))

        if check_signature and has_signature:
            vulnerabilities.extend(self._try_weak_secrets(token, header))

        if not has_signature:
            vulnerabilities.append({
                "type": "no_signature",
                "severity": "critical",
                "description": "Token has no signature - integrity cannot be verified",
                "recommendation": "Ensure tokens are properly signed",
            })

        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}
        vulnerabilities.sort(key=lambda v: severity_order.get(v.get("severity", "info"), 5))

        self.logger.info("jwt_analysis_complete", vulns=len(vulnerabilities))
        return {
            "decoded_header": header,
            "decoded_payload": payload,
            "has_signature": has_signature,
            "vulnerabilities": vulnerabilities,
            "summary": {
                "algorithm": header.get("alg", "unknown"),
                "total_vulnerabilities": len(vulnerabilities),
                "severity_breakdown": {
                    sev: sum(1 for v in vulnerabilities if v.get("severity") == sev)
                    for sev in ["critical", "high", "medium", "low", "info"]
                },
            },
        }
