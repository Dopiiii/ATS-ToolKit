"""Nuclei vulnerability scanner wrapper.

Wraps the Nuclei scanner tool to execute template-based vulnerability scanning
with configurable template categories and severity filtering.
"""

import asyncio
import json
import shutil
from typing import Any

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)


class NucleiWrapperModule(AtsModule):
    """Execute Nuclei vulnerability scanner with template and severity filtering."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="nuclei_wrapper",
            category=ModuleCategory.PENTEST,
            description="Wrap the Nuclei scanner to run template-based vulnerability scans with severity filtering",
            version="1.0.0",
            parameters=[
                Parameter(name="target", type=ParameterType.URL,
                          description="Target URL to scan", required=True),
                Parameter(name="templates", type=ParameterType.CHOICE,
                          description="Template category to use",
                          choices=["cves", "vulnerabilities", "exposures", "all"],
                          default="all"),
                Parameter(name="severity", type=ParameterType.CHOICE,
                          description="Minimum severity level to report",
                          choices=["all", "critical", "high", "medium"],
                          default="all"),
            ],
            outputs=[
                OutputField(name="findings", type="list", description="Nuclei scan findings"),
                OutputField(name="summary", type="dict", description="Scan summary and statistics"),
            ],
            tags=["pentest", "nuclei", "vulnerability", "scanner", "cve"],
            author="ATS-Toolkit",
            dangerous=False,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        target = config.get("target", "").strip()
        if not target:
            return False, "Target URL is required"
        if not target.startswith(("http://", "https://")):
            return False, "Target must start with http:// or https://"
        return True, ""

    def _check_nuclei_installed(self) -> str | None:
        """Check if nuclei binary is available in PATH."""
        path = shutil.which("nuclei")
        return path

    def _build_command(self, target: str, templates: str, severity: str,
                       nuclei_path: str) -> list[str]:
        """Build the nuclei command arguments."""
        cmd = [nuclei_path, "-u", target, "-jsonl", "-silent", "-no-color"]

        if templates != "all":
            template_map = {
                "cves": "cves",
                "vulnerabilities": "vulnerabilities",
                "exposures": "exposures",
            }
            if templates in template_map:
                cmd.extend(["-tags", template_map[templates]])

        if severity != "all":
            severity_map = {
                "critical": "critical",
                "high": "critical,high",
                "medium": "critical,high,medium",
            }
            if severity in severity_map:
                cmd.extend(["-severity", severity_map[severity]])

        cmd.extend(["-timeout", "10", "-retries", "1", "-rate-limit", "50"])
        return cmd

    def _parse_nuclei_output(self, output: str) -> list[dict[str, Any]]:
        """Parse Nuclei JSONL output into structured findings."""
        findings = []
        for line in output.strip().split("\n"):
            line = line.strip()
            if not line:
                continue
            try:
                data = json.loads(line)
                finding = {
                    "template_id": data.get("template-id", data.get("templateID", "unknown")),
                    "name": data.get("info", {}).get("name", data.get("name", "Unknown")),
                    "severity": data.get("info", {}).get("severity", data.get("severity", "unknown")),
                    "type": data.get("type", "unknown"),
                    "host": data.get("host", ""),
                    "matched_at": data.get("matched-at", data.get("matched", "")),
                    "description": data.get("info", {}).get("description", ""),
                    "reference": data.get("info", {}).get("reference", []),
                    "tags": data.get("info", {}).get("tags", []),
                    "curl_command": data.get("curl-command", ""),
                    "matcher_name": data.get("matcher-name", ""),
                    "extracted_results": data.get("extracted-results", []),
                }
                if isinstance(finding["tags"], str):
                    finding["tags"] = [t.strip() for t in finding["tags"].split(",")]
                findings.append(finding)
            except json.JSONDecodeError:
                if line and not line.startswith("["):
                    findings.append({"raw_output": line, "severity": "info"})
        return findings

    async def _run_nuclei(self, cmd: list[str], timeout_sec: int = 300) -> tuple[str, str, int]:
        """Execute nuclei as a subprocess."""
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), timeout=timeout_sec
            )
            return (
                stdout.decode(errors="replace"),
                stderr.decode(errors="replace"),
                process.returncode or 0,
            )
        except asyncio.TimeoutError:
            try:
                process.kill()
            except ProcessLookupError:
                pass
            return "", "Nuclei scan timed out", -1
        except FileNotFoundError:
            return "", "Nuclei binary not found", -1

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        target = config["target"].strip()
        templates = config.get("templates", "all")
        severity = config.get("severity", "all")

        nuclei_path = self._check_nuclei_installed()
        if not nuclei_path:
            return {
                "findings": [],
                "summary": {
                    "error": "Nuclei is not installed or not in PATH. "
                             "Install from https://github.com/projectdiscovery/nuclei",
                    "target": target,
                    "status": "failed",
                },
            }

        self.logger.info("nuclei_scan_start", target=target, templates=templates, severity=severity)

        cmd = self._build_command(target, templates, severity, nuclei_path)
        stdout, stderr, returncode = await self._run_nuclei(cmd)

        findings = self._parse_nuclei_output(stdout)

        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        for f in findings:
            sev = f.get("severity", "info").lower()
            if sev in severity_counts:
                severity_counts[sev] += 1
            else:
                severity_counts["info"] += 1

        summary = {
            "target": target,
            "templates_category": templates,
            "severity_filter": severity,
            "total_findings": len(findings),
            "severity_breakdown": severity_counts,
            "return_code": returncode,
            "status": "completed" if returncode == 0 else "error",
        }
        if stderr and returncode != 0:
            summary["stderr"] = stderr[:500]

        self.logger.info("nuclei_scan_complete", findings=len(findings), returncode=returncode)
        return {"findings": findings, "summary": summary}
