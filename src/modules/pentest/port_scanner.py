"""Asynchronous TCP port scanner.

Performs high-speed concurrent port scanning using asyncio to detect open
ports and identify running services on target hosts.
"""

import asyncio
from typing import Any

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

COMMON_PORTS = [
    21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 161, 389, 443, 445,
    465, 514, 587, 636, 993, 995, 1025, 1433, 1434, 1521, 2049, 2082,
    2083, 3306, 3389, 5432, 5900, 5985, 5986, 6379, 6443, 8080, 8443,
    8888, 9090, 9200, 9300, 27017, 27018,
]

QUICK_PORTS = [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 993, 995, 3306, 3389, 5432, 8080, 8443]

SERVICE_MAP: dict[int, str] = {
    21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS", 80: "HTTP",
    110: "POP3", 111: "RPCBind", 135: "MSRPC", 139: "NetBIOS", 143: "IMAP",
    161: "SNMP", 389: "LDAP", 443: "HTTPS", 445: "SMB", 465: "SMTPS",
    514: "Syslog", 587: "SMTP-Submission", 636: "LDAPS", 993: "IMAPS",
    995: "POP3S", 1025: "NFS-or-IIS", 1433: "MSSQL", 1434: "MSSQL-UDP",
    1521: "Oracle-DB", 2049: "NFS", 2082: "cPanel", 2083: "cPanel-SSL",
    3306: "MySQL", 3389: "RDP", 5432: "PostgreSQL", 5900: "VNC",
    5985: "WinRM-HTTP", 5986: "WinRM-HTTPS", 6379: "Redis", 6443: "Kubernetes-API",
    8080: "HTTP-Proxy", 8443: "HTTPS-Alt", 8888: "HTTP-Alt", 9090: "Prometheus",
    9200: "Elasticsearch", 9300: "Elasticsearch-Transport",
    27017: "MongoDB", 27018: "MongoDB-Shard",
}


class PortScannerModule(AtsModule):
    """Asynchronous TCP port scanner with service identification."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="port_scanner",
            category=ModuleCategory.PENTEST,
            description="Async TCP port scanner that detects open ports and identifies services",
            version="1.0.0",
            parameters=[
                Parameter(name="target", type=ParameterType.IP,
                          description="Target IP address or hostname to scan", required=True),
                Parameter(name="range", type=ParameterType.CHOICE,
                          description="Port range preset to scan",
                          choices=["quick", "common", "full", "custom"], default="quick"),
                Parameter(name="custom_ports", type=ParameterType.STRING,
                          description="Comma-separated ports or ranges (e.g. '80,443,8000-8100') for custom range",
                          required=False, default=""),
                Parameter(name="timeout", type=ParameterType.INTEGER,
                          description="Connection timeout per port in seconds",
                          default=2, min_value=1, max_value=10),
            ],
            outputs=[
                OutputField(name="open_ports", type="list", description="List of open ports with service info"),
                OutputField(name="summary", type="dict", description="Scan summary statistics"),
            ],
            tags=["pentest", "port-scan", "network", "recon", "tcp"],
            author="ATS-Toolkit",
            dangerous=False,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        target = config.get("target", "").strip()
        if not target:
            return False, "Target IP or hostname is required"
        scan_range = config.get("range", "quick")
        if scan_range == "custom":
            custom = config.get("custom_ports", "").strip()
            if not custom:
                return False, "custom_ports is required when range is 'custom'"
        return True, ""

    def _parse_ports(self, range_type: str, custom_ports: str) -> list[int]:
        """Parse port list from range type or custom specification."""
        if range_type == "quick":
            return QUICK_PORTS
        elif range_type == "common":
            return COMMON_PORTS
        elif range_type == "full":
            return list(range(1, 65536))
        elif range_type == "custom":
            ports = set()
            for part in custom_ports.split(","):
                part = part.strip()
                if "-" in part:
                    try:
                        start, end = part.split("-", 1)
                        for p in range(int(start), int(end) + 1):
                            if 1 <= p <= 65535:
                                ports.add(p)
                    except ValueError:
                        continue
                else:
                    try:
                        p = int(part)
                        if 1 <= p <= 65535:
                            ports.add(p)
                    except ValueError:
                        continue
            return sorted(ports)
        return QUICK_PORTS

    async def _scan_port(self, target: str, port: int, timeout: int,
                          semaphore: asyncio.Semaphore) -> dict[str, Any] | None:
        """Attempt to connect to a single port."""
        async with semaphore:
            try:
                _, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port), timeout=timeout
                )
                writer.close()
                await writer.wait_closed()
                service = SERVICE_MAP.get(port, "unknown")
                return {"port": port, "state": "open", "service": service}
            except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
                return None

    async def _grab_banner(self, target: str, port: int, timeout: int) -> str:
        """Try to grab a service banner from an open port."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port), timeout=timeout
            )
            banner = ""
            try:
                data = await asyncio.wait_for(reader.read(1024), timeout=2)
                banner = data.decode(errors="replace").strip()
            except asyncio.TimeoutError:
                # Some services need a probe first
                writer.write(b"HEAD / HTTP/1.0\r\n\r\n")
                await writer.drain()
                try:
                    data = await asyncio.wait_for(reader.read(1024), timeout=2)
                    banner = data.decode(errors="replace").strip()
                except asyncio.TimeoutError:
                    pass
            writer.close()
            await writer.wait_closed()
            return banner[:200] if banner else ""
        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            return ""

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        target = config["target"].strip()
        range_type = config.get("range", "quick")
        custom_ports = config.get("custom_ports", "")
        timeout = config.get("timeout", 2)

        ports = self._parse_ports(range_type, custom_ports)
        self.logger.info("port_scan_start", target=target, port_count=len(ports))

        # Limit concurrency to avoid overwhelming the network
        max_concurrent = 200 if range_type != "full" else 500
        semaphore = asyncio.Semaphore(max_concurrent)

        tasks = [self._scan_port(target, port, timeout, semaphore) for port in ports]
        results = await asyncio.gather(*tasks)
        open_ports = [r for r in results if r is not None]

        # Banner grab for open ports (limited to first 20)
        for port_info in open_ports[:20]:
            banner = await self._grab_banner(target, port_info["port"], timeout)
            if banner:
                port_info["banner"] = banner

        # Categorize findings
        high_risk_ports = {21, 23, 135, 139, 445, 1433, 3389, 5900, 6379, 27017}
        for port_info in open_ports:
            if port_info["port"] in high_risk_ports:
                port_info["risk"] = "high"
            elif port_info["port"] in (22, 80, 443, 8080, 8443):
                port_info["risk"] = "info"
            else:
                port_info["risk"] = "medium"

        summary = {
            "target": target,
            "range_type": range_type,
            "ports_scanned": len(ports),
            "open_ports_found": len(open_ports),
            "high_risk_ports": [p["port"] for p in open_ports if p.get("risk") == "high"],
            "services_found": list({p["service"] for p in open_ports if p["service"] != "unknown"}),
        }

        self.logger.info("port_scan_complete", open_ports=len(open_ports), scanned=len(ports))
        return {"open_ports": open_ports, "summary": summary}
