"""Port Scanner Module.

Fast asynchronous port scanner with service detection.
"""

import asyncio
import socket
from typing import Any, Dict, List, Tuple

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)


# Common services by port
COMMON_SERVICES = {
    21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS",
    80: "HTTP", 110: "POP3", 143: "IMAP", 443: "HTTPS", 445: "SMB",
    3306: "MySQL", 3389: "RDP", 5432: "PostgreSQL", 5900: "VNC",
    6379: "Redis", 8080: "HTTP-Proxy", 8443: "HTTPS-Alt", 27017: "MongoDB",
}

# Common port ranges
PORT_RANGES = {
    "quick": [21, 22, 23, 25, 53, 80, 443, 445, 3389, 8080],
    "common": list(range(1, 1024)),
    "full": list(range(1, 65536)),
}


class PortScannerModule(AtsModule):
    """Fast asynchronous port scanner."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="port_scanner",
            category=ModuleCategory.PENTEST,
            description="Fast asynchronous port scanner with service detection",
            version="1.0.0",
            parameters=[
                Parameter(name="target", type=ParameterType.IP, description="Target IP or hostname", required=True),
                Parameter(name="range", type=ParameterType.CHOICE, description="Port range to scan", required=False, default="quick", choices=["quick", "common", "full", "custom"]),
                Parameter(name="custom_ports", type=ParameterType.STRING, description="Custom ports (e.g., 80,443,8080 or 1-1000)", required=False),
                Parameter(name="timeout", type=ParameterType.INTEGER, description="Connection timeout (seconds)", required=False, default=2, min_value=1, max_value=30),
            ],
            outputs=[
                OutputField(name="open_ports", type="list", description="Open ports with service info"),
                OutputField(name="summary", type="dict", description="Scan summary"),
            ],
            tags=["port", "scanner", "network", "pentest"],
        )

    def validate_inputs(self, config: Dict[str, Any]) -> Tuple[bool, str]:
        target = config.get("target", "").strip()
        if not target:
            return False, "Target is required"
        return True, ""

    def _parse_port_range(self, port_string: str) -> List[int]:
        """Parse port range string like '80,443' or '1-1000'."""
        ports = []
        for part in port_string.split(","):
            part = part.strip()
            if "-" in part:
                start, end = part.split("-")
                ports.extend(range(int(start), int(end) + 1))
            else:
                ports.append(int(part))
        return ports

    async def _scan_port(self, host: str, port: int, timeout: int) -> Dict[str, Any]:
        """Scan a single port."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=timeout
            )
            writer.close()
            await writer.wait_closed()

            return {
                "port": port,
                "state": "open",
                "service": COMMON_SERVICES.get(port, "unknown"),
            }
        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            return None

    async def execute(self, config: Dict[str, Any]) -> Dict[str, Any]:
        target = config["target"].strip()
        range_selection = config.get("range", "quick")
        custom_ports = config.get("custom_ports", "")
        timeout = config.get("timeout", 2)

        self.logger.info("starting_port_scan", target=target, range=range_selection)

        # Determine ports to scan
        if range_selection == "custom" and custom_ports:
            ports = self._parse_port_range(custom_ports)
        else:
            ports = PORT_RANGES.get(range_selection, PORT_RANGES["quick"])

        # Scan ports concurrently
        tasks = [self._scan_port(target, port, timeout) for port in ports]
        results = await asyncio.gather(*tasks)

        # Filter open ports
        open_ports = [r for r in results if r is not None]

        summary = {
            "target": target,
            "ports_scanned": len(ports),
            "open_ports_count": len(open_ports),
            "services_detected": list(set(p["service"] for p in open_ports)),
        }

        self.logger.info("port_scan_complete", target=target, open_ports=len(open_ports))

        return {
            "open_ports": sorted(open_ports, key=lambda x: x["port"]),
            "summary": summary,
            "scan_config": {
                "range": range_selection,
                "timeout": timeout,
                "total_ports": len(ports),
            }
        }
