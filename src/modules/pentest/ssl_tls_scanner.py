"""SSL/TLS configuration analyzer.

Analyzes SSL/TLS configuration of target hosts including protocol versions,
cipher suites, certificate details, and known vulnerabilities.
"""

import asyncio
import ssl
import socket
import datetime
from typing import Any

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

WEAK_CIPHERS = [
    "RC4", "DES", "3DES", "NULL", "EXPORT", "anon", "MD5",
    "DES-CBC", "RC2", "IDEA", "SEED",
]

DEPRECATED_PROTOCOLS = ["SSLv2", "SSLv3", "TLSv1", "TLSv1.1"]

PROTOCOL_VERSIONS = [
    ("TLSv1.3", ssl.TLSVersion.TLSv1_3 if hasattr(ssl.TLSVersion, "TLSv1_3") else None),
    ("TLSv1.2", ssl.TLSVersion.TLSv1_2 if hasattr(ssl.TLSVersion, "TLSv1_2") else None),
    ("TLSv1.1", ssl.TLSVersion.TLSv1_1 if hasattr(ssl.TLSVersion, "TLSv1_1") else None),
    ("TLSv1.0", ssl.TLSVersion.TLSv1 if hasattr(ssl.TLSVersion, "TLSv1") else None),
]


class SslTlsScannerModule(AtsModule):
    """Analyze SSL/TLS configuration for security weaknesses."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="ssl_tls_scanner",
            category=ModuleCategory.PENTEST,
            description="Analyze SSL/TLS configuration including protocols, ciphers, and certificate details",
            version="1.0.0",
            parameters=[
                Parameter(name="target", type=ParameterType.DOMAIN,
                          description="Target hostname or domain to scan", required=True),
                Parameter(name="port", type=ParameterType.INTEGER,
                          description="Target port number",
                          default=443, min_value=1, max_value=65535),
                Parameter(name="check_level", type=ParameterType.CHOICE,
                          description="Depth of analysis to perform",
                          choices=["basic", "thorough"], default="basic"),
            ],
            outputs=[
                OutputField(name="protocol_info", type="dict", description="Supported protocol versions"),
                OutputField(name="cipher_analysis", type="dict", description="Cipher suite analysis"),
                OutputField(name="certificate_info", type="dict", description="Certificate details"),
                OutputField(name="score", type="integer", description="Security score 0-100"),
            ],
            tags=["pentest", "ssl", "tls", "certificate", "crypto", "web"],
            author="ATS-Toolkit",
            dangerous=False,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        target = config.get("target", "").strip()
        if not target:
            return False, "Target hostname is required"
        if "/" in target or " " in target:
            return False, "Target should be a hostname, not a URL"
        return True, ""

    async def _get_certificate_info(self, target: str, port: int) -> dict[str, Any]:
        """Retrieve and parse certificate information."""
        cert_info: dict[str, Any] = {}

        def _fetch_cert() -> dict[str, Any]:
            ctx = ssl.create_default_context()
            with socket.create_connection((target, port), timeout=10) as sock:
                with ctx.wrap_socket(sock, server_hostname=target) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    protocol = ssock.version()
                    return {"cert": cert, "cipher": cipher, "protocol": protocol}

        loop = asyncio.get_event_loop()
        try:
            result = await loop.run_in_executor(None, _fetch_cert)
        except (ssl.SSLError, socket.error, OSError) as e:
            return {"error": str(e)}

        cert = result["cert"]
        if cert:
            subject = dict(x[0] for x in cert.get("subject", []))
            issuer = dict(x[0] for x in cert.get("issuer", []))
            not_before = cert.get("notBefore", "")
            not_after = cert.get("notAfter", "")

            # Parse expiry
            days_until_expiry = -1
            try:
                expiry = datetime.datetime.strptime(not_after, "%b %d %H:%M:%S %Y %Z")
                days_until_expiry = (expiry - datetime.datetime.utcnow()).days
            except (ValueError, TypeError):
                pass

            san_list = []
            for san_type, san_value in cert.get("subjectAltName", []):
                san_list.append(f"{san_type}:{san_value}")

            cert_info = {
                "subject": subject,
                "issuer": issuer,
                "common_name": subject.get("commonName", ""),
                "issuer_cn": issuer.get("commonName", ""),
                "organization": issuer.get("organizationName", ""),
                "not_before": not_before,
                "not_after": not_after,
                "days_until_expiry": days_until_expiry,
                "serial_number": cert.get("serialNumber", ""),
                "san": san_list,
                "version": cert.get("version", 0),
            }

        cert_info["negotiated_protocol"] = result["protocol"]
        cert_info["negotiated_cipher"] = result["cipher"]
        return cert_info

    async def _check_protocol_support(self, target: str, port: int) -> dict[str, Any]:
        """Test which TLS protocol versions are supported."""
        supported = {}

        def _test_protocol(proto_name: str, proto_version: Any) -> bool:
            if proto_version is None:
                return False
            try:
                ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                ctx.minimum_version = proto_version
                ctx.maximum_version = proto_version
                with socket.create_connection((target, port), timeout=5) as sock:
                    with ctx.wrap_socket(sock, server_hostname=target) as ssock:
                        return True
            except (ssl.SSLError, socket.error, OSError, ValueError):
                return False

        loop = asyncio.get_event_loop()
        for proto_name, proto_version in PROTOCOL_VERSIONS:
            try:
                result = await loop.run_in_executor(
                    None, _test_protocol, proto_name, proto_version
                )
                supported[proto_name] = result
            except Exception:
                supported[proto_name] = False

        return supported

    async def _analyze_ciphers(self, target: str, port: int) -> dict[str, Any]:
        """Analyze the cipher suites offered by the server."""

        def _get_ciphers() -> list[tuple]:
            ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            try:
                with socket.create_connection((target, port), timeout=10) as sock:
                    with ctx.wrap_socket(sock, server_hostname=target) as ssock:
                        return ssock.shared_ciphers() or []
            except (ssl.SSLError, socket.error, OSError):
                return []

        loop = asyncio.get_event_loop()
        try:
            ciphers = await loop.run_in_executor(None, _get_ciphers)
        except Exception:
            ciphers = []

        weak = []
        strong = []
        for cipher_tuple in ciphers:
            name = cipher_tuple[0] if isinstance(cipher_tuple, tuple) else str(cipher_tuple)
            is_weak = any(w in name.upper() for w in [c.upper() for c in WEAK_CIPHERS])
            entry = {"name": name, "protocol": cipher_tuple[1] if len(cipher_tuple) > 1 else "",
                     "bits": cipher_tuple[2] if len(cipher_tuple) > 2 else 0}
            if is_weak:
                weak.append(entry)
            else:
                strong.append(entry)

        return {
            "total_ciphers": len(ciphers),
            "strong_ciphers": strong,
            "weak_ciphers": weak,
            "has_weak_ciphers": len(weak) > 0,
        }

    def _calculate_score(self, protocol_info: dict, cipher_analysis: dict,
                          cert_info: dict) -> int:
        """Calculate an overall security score from 0-100."""
        score = 100

        # Protocol penalties
        if protocol_info.get("TLSv1.0"):
            score -= 20
        if protocol_info.get("TLSv1.1"):
            score -= 15
        if not protocol_info.get("TLSv1.2") and not protocol_info.get("TLSv1.3"):
            score -= 30

        # Bonus for TLS 1.3
        if protocol_info.get("TLSv1.3"):
            score = min(score + 5, 100)

        # Cipher penalties
        if cipher_analysis.get("has_weak_ciphers"):
            weak_count = len(cipher_analysis.get("weak_ciphers", []))
            score -= min(weak_count * 5, 25)

        # Certificate penalties
        days = cert_info.get("days_until_expiry", -1)
        if days < 0:
            score -= 20
        elif days < 30:
            score -= 15
        elif days < 90:
            score -= 5

        if cert_info.get("error"):
            score -= 25

        return max(0, min(100, score))

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        target = config["target"].strip()
        port = config.get("port", 443)
        check_level = config.get("check_level", "basic")

        self.logger.info("ssl_scan_start", target=target, port=port, level=check_level)

        cert_info = await self._get_certificate_info(target, port)

        protocol_info: dict[str, Any] = {}
        cipher_analysis: dict[str, Any] = {"total_ciphers": 0, "strong_ciphers": [],
                                            "weak_ciphers": [], "has_weak_ciphers": False}

        if check_level == "thorough":
            protocol_info = await self._check_protocol_support(target, port)
            cipher_analysis = await self._analyze_ciphers(target, port)
        else:
            negotiated = cert_info.get("negotiated_protocol", "")
            protocol_info = {"negotiated": negotiated}
            cipher_tuple = cert_info.get("negotiated_cipher", ())
            if cipher_tuple:
                cipher_name = cipher_tuple[0] if isinstance(cipher_tuple, tuple) else str(cipher_tuple)
                is_weak = any(w in cipher_name.upper() for w in [c.upper() for c in WEAK_CIPHERS])
                cipher_analysis = {
                    "negotiated_cipher": cipher_name,
                    "has_weak_ciphers": is_weak,
                    "total_ciphers": 1,
                    "strong_ciphers": [] if is_weak else [{"name": cipher_name}],
                    "weak_ciphers": [{"name": cipher_name}] if is_weak else [],
                }

        # Build vulnerability findings
        vulnerabilities = []
        for proto in DEPRECATED_PROTOCOLS:
            if protocol_info.get(proto):
                vulnerabilities.append({
                    "issue": f"Deprecated protocol {proto} is supported",
                    "severity": "high" if proto in ("SSLv2", "SSLv3") else "medium",
                })
        if cipher_analysis.get("has_weak_ciphers"):
            for wc in cipher_analysis.get("weak_ciphers", []):
                vulnerabilities.append({
                    "issue": f"Weak cipher supported: {wc['name']}",
                    "severity": "medium",
                })
        days = cert_info.get("days_until_expiry", -1)
        if days < 0 and not cert_info.get("error"):
            vulnerabilities.append({"issue": "Certificate has expired", "severity": "critical"})
        elif 0 <= days < 30:
            vulnerabilities.append({"issue": f"Certificate expires in {days} days", "severity": "high"})

        score = self._calculate_score(protocol_info, cipher_analysis, cert_info)

        self.logger.info("ssl_scan_complete", target=target, score=score, vulns=len(vulnerabilities))
        return {
            "protocol_info": protocol_info,
            "cipher_analysis": cipher_analysis,
            "certificate_info": cert_info,
            "vulnerabilities": vulnerabilities,
            "score": score,
        }
