"""Subdomain takeover vulnerability scanner.

Checks for subdomain takeover vulnerabilities by resolving CNAME records,
detecting dangling DNS entries, and fingerprinting unclaimed third-party services.
"""

import asyncio
import re
from typing import Any
from urllib.parse import urlparse

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

# Fingerprints for services known to be vulnerable to subdomain takeover.
# Each entry: (service_name, cname_patterns, response_fingerprints, severity)
SERVICE_FINGERPRINTS: list[tuple[str, list[str], list[str], str]] = [
    ("GitHub Pages", [r"\.github\.io$"],
     ["There isn't a GitHub Pages site here.", "For root URLs (like http://example.com/)"],
     "high"),
    ("Heroku", [r"\.herokuapp\.com$", r"\.herokussl\.com$"],
     ["No such app", "no-such-app", "herokucdn.com/error-pages"],
     "high"),
    ("AWS S3", [r"\.s3\.amazonaws\.com$", r"\.s3-website[.-]"],
     ["NoSuchBucket", "The specified bucket does not exist"],
     "critical"),
    ("AWS Elastic Beanstalk", [r"\.elasticbeanstalk\.com$"],
     ["NXDOMAIN"],
     "high"),
    ("Azure", [r"\.azurewebsites\.net$", r"\.cloudapp\.net$", r"\.azure-api\.net$",
               r"\.azurefd\.net$", r"\.blob\.core\.windows\.net$", r"\.trafficmanager\.net$"],
     ["404 Web Site not found", "The resource you are looking for has been removed"],
     "high"),
    ("Shopify", [r"\.myshopify\.com$"],
     ["Sorry, this shop is currently unavailable", "Only one step left"],
     "high"),
    ("Fastly", [r"\.fastly\.net$", r"\.fastlylb\.net$"],
     ["Fastly error: unknown domain"],
     "high"),
    ("Pantheon", [r"\.pantheonsite\.io$"],
     ["404 error unknown site", "The gods are wise"],
     "high"),
    ("Tumblr", [r"\.tumblr\.com$"],
     ["There's nothing here.", "Whatever you were looking for doesn't currently exist"],
     "medium"),
    ("WordPress.com", [r"\.wordpress\.com$"],
     ["Do you want to register"],
     "medium"),
    ("Ghost", [r"\.ghost\.io$"],
     ["The thing you were looking for is no longer here"],
     "high"),
    ("Surge.sh", [r"\.surge\.sh$"],
     ["project not found"],
     "high"),
    ("Bitbucket", [r"\.bitbucket\.io$"],
     ["Repository not found"],
     "high"),
    ("Zendesk", [r"\.zendesk\.com$"],
     ["Help Center Closed", "Oops, this help center"],
     "medium"),
    ("Unbounce", [r"\.unbouncepages\.com$"],
     ["The requested URL was not found on this server"],
     "high"),
    ("HubSpot", [r"\.hubspot\.net$", r"\.hs-sites\.com$"],
     ["Domain not found", "does not exist"],
     "medium"),
    ("Fly.io", [r"\.fly\.dev$"],
     ["404 Not Found"],
     "high"),
    ("Netlify", [r"\.netlify\.app$", r"\.netlify\.com$"],
     ["Not Found - Request ID"],
     "high"),
    ("Vercel", [r"\.vercel\.app$", r"\.now\.sh$"],
     ["The deployment could not be found"],
     "high"),
    ("Cargo Collective", [r"\.cargocollective\.com$"],
     ["404 Not Found"],
     "medium"),
    ("Readme.io", [r"\.readme\.io$"],
     ["Project doesnt exist"],
     "medium"),
    ("Tilda", [r"\.tilda\.ws$"],
     ["Please renew your subscription"],
     "medium"),
    ("Strikingly", [r"\.strikinglydns\.com$"],
     ["page not found"],
     "high"),
    ("Feedpress", [r"\.redirect\.feedpress\.me$"],
     ["The feed has not been found"],
     "medium"),
    ("Agile CRM", [r"\.agilecrm\.com$"],
     ["Sorry, this page is no longer available"],
     "medium"),
    ("Campaignmonitor", [r"\.createsend\.com$"],
     ["Double opt-in", "Trying to access your account?"],
     "medium"),
]

# Common CNAME patterns indicating potential dangling records
DANGLING_INDICATORS = [
    "NXDOMAIN",
    "SERVFAIL",
    "REFUSED",
]

# DNS resolution via HTTP-based DNS APIs (DoH)
DOH_ENDPOINTS = [
    "https://cloudflare-dns.com/dns-query",
    "https://dns.google/resolve",
]


class SubdomainTakeoverModule(AtsModule):
    """Check subdomains for takeover vulnerabilities via dangling CNAME records."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="subdomain_takeover",
            category=ModuleCategory.PENTEST,
            description="Check for subdomain takeover vulnerabilities by detecting dangling CNAME records and unclaimed third-party services",
            version="1.0.0",
            parameters=[
                Parameter(name="subdomains", type=ParameterType.STRING,
                          description="Comma-separated list of subdomains to check (e.g. blog.example.com,shop.example.com)",
                          required=True),
                Parameter(name="check_http", type=ParameterType.BOOLEAN,
                          description="Also send HTTP requests to check for service fingerprints",
                          default=True),
                Parameter(name="timeout", type=ParameterType.INTEGER,
                          description="Request timeout in seconds",
                          default=10),
            ],
            outputs=[
                OutputField(name="vulnerabilities", type="list",
                            description="Confirmed or potential subdomain takeover findings"),
                OutputField(name="dns_results", type="list",
                            description="DNS resolution results for all subdomains"),
                OutputField(name="summary", type="dict",
                            description="Scan summary with statistics"),
            ],
            requires_api_key=False,
            api_key_service=None,
            tags=["pentest", "subdomain", "takeover", "dns", "cname", "web"],
            author="ATS-Toolkit",
            dangerous=True,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        subdomains = config.get("subdomains", "").strip()
        if not subdomains:
            return False, "At least one subdomain is required"
        for sub in subdomains.split(","):
            sub = sub.strip()
            if not sub:
                continue
            if not re.match(r'^[a-zA-Z0-9]([a-zA-Z0-9\-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]*[a-zA-Z0-9])?)*\.[a-zA-Z]{2,}$', sub):
                return False, f"Invalid subdomain format: {sub}"
        return True, ""

    def _parse_subdomains(self, raw: str) -> list[str]:
        """Parse and deduplicate the comma-separated subdomain list."""
        subs = []
        seen: set[str] = set()
        for s in raw.split(","):
            s = s.strip().lower()
            if s and s not in seen:
                subs.append(s)
                seen.add(s)
        return subs

    def _match_service(self, cname: str) -> list[dict[str, str]]:
        """Match a CNAME value against known vulnerable service fingerprints."""
        matches = []
        for service_name, cname_patterns, _, severity in SERVICE_FINGERPRINTS:
            for pattern in cname_patterns:
                if re.search(pattern, cname, re.IGNORECASE):
                    matches.append({
                        "service": service_name,
                        "cname_pattern": pattern,
                        "severity": severity,
                    })
                    break
        return matches

    def _check_body_fingerprint(self, body: str) -> list[dict[str, str]]:
        """Check HTTP response body for service-specific takeover fingerprints."""
        matches = []
        for service_name, _, fingerprints, severity in SERVICE_FINGERPRINTS:
            for fp in fingerprints:
                if fp.lower() in body.lower():
                    matches.append({
                        "service": service_name,
                        "fingerprint": fp,
                        "severity": severity,
                    })
                    break
        return matches

    async def _resolve_cname_doh(self, session: aiohttp.ClientSession,
                                  subdomain: str, timeout: int) -> dict[str, Any]:
        """Resolve CNAME records using DNS-over-HTTPS (Cloudflare or Google)."""
        result: dict[str, Any] = {
            "subdomain": subdomain,
            "cnames": [],
            "a_records": [],
            "nxdomain": False,
            "error": None,
        }

        for endpoint in DOH_ENDPOINTS:
            try:
                params = {"name": subdomain, "type": "CNAME"}
                headers = {"Accept": "application/dns-json"}
                async with session.get(endpoint, params=params, headers=headers,
                                       timeout=aiohttp.ClientTimeout(total=timeout),
                                       ssl=False) as resp:
                    if resp.status != 200:
                        continue
                    data = await resp.json(content_type=None)

                    status = data.get("Status", -1)
                    if status == 3:  # NXDOMAIN
                        result["nxdomain"] = True

                    answers = data.get("Answer", [])
                    for ans in answers:
                        rtype = ans.get("type", 0)
                        rdata = ans.get("data", "").rstrip(".")
                        if rtype == 5:  # CNAME
                            result["cnames"].append(rdata)
                        elif rtype == 1:  # A
                            result["a_records"].append(rdata)

                # Also resolve A records
                params_a = {"name": subdomain, "type": "A"}
                async with session.get(endpoint, params=params_a, headers=headers,
                                       timeout=aiohttp.ClientTimeout(total=timeout),
                                       ssl=False) as resp_a:
                    if resp_a.status == 200:
                        data_a = await resp_a.json(content_type=None)
                        for ans in data_a.get("Answer", []):
                            if ans.get("type") == 1:
                                rdata = ans.get("data", "")
                                if rdata and rdata not in result["a_records"]:
                                    result["a_records"].append(rdata)

                return result  # success with first endpoint
            except (aiohttp.ClientError, asyncio.TimeoutError, ValueError):
                continue

        result["error"] = "All DoH endpoints failed"
        return result

    async def _check_http_fingerprint(self, session: aiohttp.ClientSession,
                                       subdomain: str, timeout: int) -> dict[str, Any]:
        """Send HTTP/HTTPS requests and check response for takeover fingerprints."""
        result: dict[str, Any] = {
            "subdomain": subdomain,
            "http_status": None,
            "https_status": None,
            "body_fingerprints": [],
            "title": None,
            "error": None,
        }

        for scheme in ("https", "http"):
            url = f"{scheme}://{subdomain}/"
            try:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=timeout),
                                       ssl=False, allow_redirects=True) as resp:
                    status = resp.status
                    body = await resp.text(errors="replace")

                    if scheme == "https":
                        result["https_status"] = status
                    else:
                        result["http_status"] = status

                    # Extract title
                    title_match = re.search(r'<title[^>]*>(.*?)</title>', body,
                                            re.IGNORECASE | re.DOTALL)
                    if title_match:
                        result["title"] = title_match.group(1).strip()[:200]

                    # Check body against fingerprints
                    fingerprints = self._check_body_fingerprint(body)
                    for fp in fingerprints:
                        fp["scheme"] = scheme
                        fp["status_code"] = status
                    result["body_fingerprints"].extend(fingerprints)

                    # If HTTPS worked, no need to try HTTP
                    if scheme == "https" and status < 500:
                        break

            except (aiohttp.ClientError, asyncio.TimeoutError):
                if scheme == "https":
                    result["https_status"] = "connection_failed"
                else:
                    result["http_status"] = "connection_failed"
                continue

        return result

    async def _analyze_subdomain(self, session: aiohttp.ClientSession,
                                  subdomain: str, check_http: bool,
                                  timeout: int) -> dict[str, Any]:
        """Full analysis pipeline for a single subdomain."""
        analysis: dict[str, Any] = {
            "subdomain": subdomain,
            "dns": None,
            "http": None,
            "vulnerable": False,
            "findings": [],
        }

        # Step 1: DNS resolution
        dns_result = await self._resolve_cname_doh(session, subdomain, timeout)
        analysis["dns"] = dns_result

        # Step 2: Check CNAME against known services
        for cname in dns_result.get("cnames", []):
            service_matches = self._match_service(cname)
            for match in service_matches:
                finding = {
                    "type": "cname_match",
                    "subdomain": subdomain,
                    "cname": cname,
                    "service": match["service"],
                    "severity": match["severity"],
                    "description": f"CNAME points to {match['service']} ({cname}) - potential takeover if service is unclaimed",
                }
                analysis["findings"].append(finding)

        # Step 3: Check for dangling CNAME (NXDOMAIN with CNAME)
        if dns_result.get("nxdomain") and dns_result.get("cnames"):
            finding = {
                "type": "dangling_cname",
                "subdomain": subdomain,
                "cnames": dns_result["cnames"],
                "severity": "critical",
                "description": f"Dangling CNAME detected: {subdomain} has CNAME records but resolves to NXDOMAIN",
            }
            analysis["findings"].append(finding)
            analysis["vulnerable"] = True

        # Step 4: HTTP fingerprint check
        if check_http:
            http_result = await self._check_http_fingerprint(session, subdomain, timeout)
            analysis["http"] = http_result

            for fp in http_result.get("body_fingerprints", []):
                finding = {
                    "type": "http_fingerprint",
                    "subdomain": subdomain,
                    "service": fp["service"],
                    "fingerprint": fp["fingerprint"],
                    "status_code": fp.get("status_code"),
                    "severity": fp["severity"],
                    "description": f"HTTP response matches {fp['service']} takeover fingerprint: '{fp['fingerprint']}'",
                }
                analysis["findings"].append(finding)
                analysis["vulnerable"] = True

            # Connection failure on a CNAME-pointed subdomain is suspicious
            both_failed = (http_result.get("https_status") == "connection_failed"
                           and http_result.get("http_status") == "connection_failed")
            if both_failed and dns_result.get("cnames"):
                finding = {
                    "type": "unreachable_cname",
                    "subdomain": subdomain,
                    "cnames": dns_result["cnames"],
                    "severity": "medium",
                    "description": f"Subdomain has CNAME but HTTP is unreachable - possible dangling record",
                }
                analysis["findings"].append(finding)

        # Mark as vulnerable if we have CNAME service match + NXDOMAIN or fingerprint
        if analysis["findings"] and not analysis["vulnerable"]:
            has_cname_match = any(f["type"] == "cname_match" for f in analysis["findings"])
            has_nxdomain = dns_result.get("nxdomain", False)
            if has_cname_match and has_nxdomain:
                analysis["vulnerable"] = True

        return analysis

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        raw_subs = config["subdomains"].strip()
        check_http = config.get("check_http", True)
        timeout = config.get("timeout", 10)

        subdomains = self._parse_subdomains(raw_subs)

        self.logger.info("subdomain_takeover_start", count=len(subdomains))

        connector = aiohttp.TCPConnector(limit=15, ssl=False)
        all_vulns: list[dict[str, Any]] = []
        dns_results: list[dict[str, Any]] = []

        async with aiohttp.ClientSession(connector=connector) as session:
            tasks = [
                self._analyze_subdomain(session, sub, check_http, timeout)
                for sub in subdomains
            ]
            analyses = await asyncio.gather(*tasks)

            for analysis in analyses:
                dns_results.append({
                    "subdomain": analysis["subdomain"],
                    "dns": analysis["dns"],
                    "http": analysis.get("http"),
                })
                if analysis["findings"]:
                    for finding in analysis["findings"]:
                        all_vulns.append(finding)

        summary = {
            "subdomains_tested": len(subdomains),
            "total_findings": len(all_vulns),
            "vulnerable_subdomains": sum(1 for a in analyses if a["vulnerable"]),
            "severity_breakdown": {
                "critical": sum(1 for v in all_vulns if v.get("severity") == "critical"),
                "high": sum(1 for v in all_vulns if v.get("severity") == "high"),
                "medium": sum(1 for v in all_vulns if v.get("severity") == "medium"),
                "low": sum(1 for v in all_vulns if v.get("severity") == "low"),
            },
        }

        self.logger.info("subdomain_takeover_complete", vulns=len(all_vulns),
                         tested=len(subdomains))
        return {"vulnerabilities": all_vulns, "dns_results": dns_results, "summary": summary}
